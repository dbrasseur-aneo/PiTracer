// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: objects.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_objects_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_objects_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/duration.pb.h>
#include "task_status.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_objects_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_objects_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[22]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_objects_2eproto;
namespace ArmoniK {
namespace api {
namespace grpc {
namespace v1 {
class Configuration;
struct ConfigurationDefaultTypeInternal;
extern ConfigurationDefaultTypeInternal _Configuration_default_instance_;
class Count;
struct CountDefaultTypeInternal;
extern CountDefaultTypeInternal _Count_default_instance_;
class CreateTaskReply;
struct CreateTaskReplyDefaultTypeInternal;
extern CreateTaskReplyDefaultTypeInternal _CreateTaskReply_default_instance_;
class CreateTaskReply_TaskIds;
struct CreateTaskReply_TaskIdsDefaultTypeInternal;
extern CreateTaskReply_TaskIdsDefaultTypeInternal _CreateTaskReply_TaskIds_default_instance_;
class DataChunk;
struct DataChunkDefaultTypeInternal;
extern DataChunkDefaultTypeInternal _DataChunk_default_instance_;
class Empty;
struct EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class Error;
struct ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class InitKeyedDataStream;
struct InitKeyedDataStreamDefaultTypeInternal;
extern InitKeyedDataStreamDefaultTypeInternal _InitKeyedDataStream_default_instance_;
class InitTaskRequest;
struct InitTaskRequestDefaultTypeInternal;
extern InitTaskRequestDefaultTypeInternal _InitTaskRequest_default_instance_;
class Output;
struct OutputDefaultTypeInternal;
extern OutputDefaultTypeInternal _Output_default_instance_;
class Output_Error;
struct Output_ErrorDefaultTypeInternal;
extern Output_ErrorDefaultTypeInternal _Output_Error_default_instance_;
class ResultRequest;
struct ResultRequestDefaultTypeInternal;
extern ResultRequestDefaultTypeInternal _ResultRequest_default_instance_;
class StatusCount;
struct StatusCountDefaultTypeInternal;
extern StatusCountDefaultTypeInternal _StatusCount_default_instance_;
class TaskError;
struct TaskErrorDefaultTypeInternal;
extern TaskErrorDefaultTypeInternal _TaskError_default_instance_;
class TaskId;
struct TaskIdDefaultTypeInternal;
extern TaskIdDefaultTypeInternal _TaskId_default_instance_;
class TaskIdList;
struct TaskIdListDefaultTypeInternal;
extern TaskIdListDefaultTypeInternal _TaskIdList_default_instance_;
class TaskIdWithStatus;
struct TaskIdWithStatusDefaultTypeInternal;
extern TaskIdWithStatusDefaultTypeInternal _TaskIdWithStatus_default_instance_;
class TaskList;
struct TaskListDefaultTypeInternal;
extern TaskListDefaultTypeInternal _TaskList_default_instance_;
class TaskOptions;
struct TaskOptionsDefaultTypeInternal;
extern TaskOptionsDefaultTypeInternal _TaskOptions_default_instance_;
class TaskOptions_OptionsEntry_DoNotUse;
struct TaskOptions_OptionsEntry_DoNotUseDefaultTypeInternal;
extern TaskOptions_OptionsEntry_DoNotUseDefaultTypeInternal _TaskOptions_OptionsEntry_DoNotUse_default_instance_;
class TaskRequest;
struct TaskRequestDefaultTypeInternal;
extern TaskRequestDefaultTypeInternal _TaskRequest_default_instance_;
class TaskRequestHeader;
struct TaskRequestHeaderDefaultTypeInternal;
extern TaskRequestHeaderDefaultTypeInternal _TaskRequestHeader_default_instance_;
}  // namespace v1
}  // namespace grpc
}  // namespace api
}  // namespace ArmoniK
PROTOBUF_NAMESPACE_OPEN
template<> ::ArmoniK::api::grpc::v1::Configuration* Arena::CreateMaybeMessage<::ArmoniK::api::grpc::v1::Configuration>(Arena*);
template<> ::ArmoniK::api::grpc::v1::Count* Arena::CreateMaybeMessage<::ArmoniK::api::grpc::v1::Count>(Arena*);
template<> ::ArmoniK::api::grpc::v1::CreateTaskReply* Arena::CreateMaybeMessage<::ArmoniK::api::grpc::v1::CreateTaskReply>(Arena*);
template<> ::ArmoniK::api::grpc::v1::CreateTaskReply_TaskIds* Arena::CreateMaybeMessage<::ArmoniK::api::grpc::v1::CreateTaskReply_TaskIds>(Arena*);
template<> ::ArmoniK::api::grpc::v1::DataChunk* Arena::CreateMaybeMessage<::ArmoniK::api::grpc::v1::DataChunk>(Arena*);
template<> ::ArmoniK::api::grpc::v1::Empty* Arena::CreateMaybeMessage<::ArmoniK::api::grpc::v1::Empty>(Arena*);
template<> ::ArmoniK::api::grpc::v1::Error* Arena::CreateMaybeMessage<::ArmoniK::api::grpc::v1::Error>(Arena*);
template<> ::ArmoniK::api::grpc::v1::InitKeyedDataStream* Arena::CreateMaybeMessage<::ArmoniK::api::grpc::v1::InitKeyedDataStream>(Arena*);
template<> ::ArmoniK::api::grpc::v1::InitTaskRequest* Arena::CreateMaybeMessage<::ArmoniK::api::grpc::v1::InitTaskRequest>(Arena*);
template<> ::ArmoniK::api::grpc::v1::Output* Arena::CreateMaybeMessage<::ArmoniK::api::grpc::v1::Output>(Arena*);
template<> ::ArmoniK::api::grpc::v1::Output_Error* Arena::CreateMaybeMessage<::ArmoniK::api::grpc::v1::Output_Error>(Arena*);
template<> ::ArmoniK::api::grpc::v1::ResultRequest* Arena::CreateMaybeMessage<::ArmoniK::api::grpc::v1::ResultRequest>(Arena*);
template<> ::ArmoniK::api::grpc::v1::StatusCount* Arena::CreateMaybeMessage<::ArmoniK::api::grpc::v1::StatusCount>(Arena*);
template<> ::ArmoniK::api::grpc::v1::TaskError* Arena::CreateMaybeMessage<::ArmoniK::api::grpc::v1::TaskError>(Arena*);
template<> ::ArmoniK::api::grpc::v1::TaskId* Arena::CreateMaybeMessage<::ArmoniK::api::grpc::v1::TaskId>(Arena*);
template<> ::ArmoniK::api::grpc::v1::TaskIdList* Arena::CreateMaybeMessage<::ArmoniK::api::grpc::v1::TaskIdList>(Arena*);
template<> ::ArmoniK::api::grpc::v1::TaskIdWithStatus* Arena::CreateMaybeMessage<::ArmoniK::api::grpc::v1::TaskIdWithStatus>(Arena*);
template<> ::ArmoniK::api::grpc::v1::TaskList* Arena::CreateMaybeMessage<::ArmoniK::api::grpc::v1::TaskList>(Arena*);
template<> ::ArmoniK::api::grpc::v1::TaskOptions* Arena::CreateMaybeMessage<::ArmoniK::api::grpc::v1::TaskOptions>(Arena*);
template<> ::ArmoniK::api::grpc::v1::TaskOptions_OptionsEntry_DoNotUse* Arena::CreateMaybeMessage<::ArmoniK::api::grpc::v1::TaskOptions_OptionsEntry_DoNotUse>(Arena*);
template<> ::ArmoniK::api::grpc::v1::TaskRequest* Arena::CreateMaybeMessage<::ArmoniK::api::grpc::v1::TaskRequest>(Arena*);
template<> ::ArmoniK::api::grpc::v1::TaskRequestHeader* Arena::CreateMaybeMessage<::ArmoniK::api::grpc::v1::TaskRequestHeader>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ArmoniK {
namespace api {
namespace grpc {
namespace v1 {

// ===================================================================

class Empty final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ArmoniK.api.grpc.v1.Empty) */ {
 public:
  inline Empty() : Empty(nullptr) {}
  explicit constexpr Empty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Empty(const Empty& from);
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  inline Empty& operator=(Empty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Empty& default_instance() {
    return *internal_default_instance();
  }
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }
  inline void Swap(Empty* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Empty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Empty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ArmoniK.api.grpc.v1.Empty";
  }
  protected:
  explicit Empty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ArmoniK.api.grpc.v1.Empty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_objects_2eproto;
};
// -------------------------------------------------------------------

class TaskOptions_OptionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TaskOptions_OptionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TaskOptions_OptionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  TaskOptions_OptionsEntry_DoNotUse();
  explicit constexpr TaskOptions_OptionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TaskOptions_OptionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TaskOptions_OptionsEntry_DoNotUse& other);
  static const TaskOptions_OptionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TaskOptions_OptionsEntry_DoNotUse*>(&_TaskOptions_OptionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "ArmoniK.api.grpc.v1.TaskOptions.OptionsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "ArmoniK.api.grpc.v1.TaskOptions.OptionsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class TaskOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ArmoniK.api.grpc.v1.TaskOptions) */ {
 public:
  inline TaskOptions() : TaskOptions(nullptr) {}
  ~TaskOptions() override;
  explicit constexpr TaskOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskOptions(const TaskOptions& from);
  TaskOptions(TaskOptions&& from) noexcept
    : TaskOptions() {
    *this = ::std::move(from);
  }

  inline TaskOptions& operator=(const TaskOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskOptions& operator=(TaskOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskOptions* internal_default_instance() {
    return reinterpret_cast<const TaskOptions*>(
               &_TaskOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TaskOptions& a, TaskOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TaskOptions& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ArmoniK.api.grpc.v1.TaskOptions";
  }
  protected:
  explicit TaskOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kOptionsFieldNumber = 1,
    kMaxDurationFieldNumber = 2,
    kMaxRetriesFieldNumber = 3,
    kPriorityFieldNumber = 4,
  };
  // map<string, string> Options = 1;
  int options_size() const;
  private:
  int _internal_options_size() const;
  public:
  void clear_options();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_options() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_options();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      options() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_options();

  // .google.protobuf.Duration MaxDuration = 2;
  bool has_maxduration() const;
  private:
  bool _internal_has_maxduration() const;
  public:
  void clear_maxduration();
  const ::PROTOBUF_NAMESPACE_ID::Duration& maxduration() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_maxduration();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_maxduration();
  void set_allocated_maxduration(::PROTOBUF_NAMESPACE_ID::Duration* maxduration);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_maxduration() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_maxduration();
  public:
  void unsafe_arena_set_allocated_maxduration(
      ::PROTOBUF_NAMESPACE_ID::Duration* maxduration);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_maxduration();

  // int32 MaxRetries = 3;
  void clear_maxretries();
  int32_t maxretries() const;
  void set_maxretries(int32_t value);
  private:
  int32_t _internal_maxretries() const;
  void _internal_set_maxretries(int32_t value);
  public:

  // int32 Priority = 4;
  void clear_priority();
  int32_t priority() const;
  void set_priority(int32_t value);
  private:
  int32_t _internal_priority() const;
  void _internal_set_priority(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ArmoniK.api.grpc.v1.TaskOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      TaskOptions_OptionsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> options_;
  ::PROTOBUF_NAMESPACE_ID::Duration* maxduration_;
  int32_t maxretries_;
  int32_t priority_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_objects_2eproto;
};
// -------------------------------------------------------------------

class Configuration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ArmoniK.api.grpc.v1.Configuration) */ {
 public:
  inline Configuration() : Configuration(nullptr) {}
  ~Configuration() override;
  explicit constexpr Configuration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Configuration(const Configuration& from);
  Configuration(Configuration&& from) noexcept
    : Configuration() {
    *this = ::std::move(from);
  }

  inline Configuration& operator=(const Configuration& from) {
    CopyFrom(from);
    return *this;
  }
  inline Configuration& operator=(Configuration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Configuration& default_instance() {
    return *internal_default_instance();
  }
  static inline const Configuration* internal_default_instance() {
    return reinterpret_cast<const Configuration*>(
               &_Configuration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Configuration& a, Configuration& b) {
    a.Swap(&b);
  }
  inline void Swap(Configuration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Configuration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Configuration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Configuration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Configuration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Configuration& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Configuration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ArmoniK.api.grpc.v1.Configuration";
  }
  protected:
  explicit Configuration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataChunkMaxSizeFieldNumber = 1,
  };
  // int32 data_chunk_max_size = 1;
  void clear_data_chunk_max_size();
  int32_t data_chunk_max_size() const;
  void set_data_chunk_max_size(int32_t value);
  private:
  int32_t _internal_data_chunk_max_size() const;
  void _internal_set_data_chunk_max_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ArmoniK.api.grpc.v1.Configuration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t data_chunk_max_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_objects_2eproto;
};
// -------------------------------------------------------------------

class Output_Error final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ArmoniK.api.grpc.v1.Output.Error) */ {
 public:
  inline Output_Error() : Output_Error(nullptr) {}
  ~Output_Error() override;
  explicit constexpr Output_Error(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Output_Error(const Output_Error& from);
  Output_Error(Output_Error&& from) noexcept
    : Output_Error() {
    *this = ::std::move(from);
  }

  inline Output_Error& operator=(const Output_Error& from) {
    CopyFrom(from);
    return *this;
  }
  inline Output_Error& operator=(Output_Error&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Output_Error& default_instance() {
    return *internal_default_instance();
  }
  static inline const Output_Error* internal_default_instance() {
    return reinterpret_cast<const Output_Error*>(
               &_Output_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Output_Error& a, Output_Error& b) {
    a.Swap(&b);
  }
  inline void Swap(Output_Error* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Output_Error* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Output_Error* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Output_Error>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Output_Error& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Output_Error& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Output_Error* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ArmoniK.api.grpc.v1.Output.Error";
  }
  protected:
  explicit Output_Error(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDetailsFieldNumber = 1,
    kKillSubTasksFieldNumber = 2,
  };
  // string details = 1;
  void clear_details();
  const std::string& details() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_details(ArgT0&& arg0, ArgT... args);
  std::string* mutable_details();
  PROTOBUF_NODISCARD std::string* release_details();
  void set_allocated_details(std::string* details);
  private:
  const std::string& _internal_details() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_details(const std::string& value);
  std::string* _internal_mutable_details();
  public:

  // bool kill_sub_tasks = 2;
  void clear_kill_sub_tasks();
  bool kill_sub_tasks() const;
  void set_kill_sub_tasks(bool value);
  private:
  bool _internal_kill_sub_tasks() const;
  void _internal_set_kill_sub_tasks(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ArmoniK.api.grpc.v1.Output.Error)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr details_;
  bool kill_sub_tasks_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_objects_2eproto;
};
// -------------------------------------------------------------------

class Output final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ArmoniK.api.grpc.v1.Output) */ {
 public:
  inline Output() : Output(nullptr) {}
  ~Output() override;
  explicit constexpr Output(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Output(const Output& from);
  Output(Output&& from) noexcept
    : Output() {
    *this = ::std::move(from);
  }

  inline Output& operator=(const Output& from) {
    CopyFrom(from);
    return *this;
  }
  inline Output& operator=(Output&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Output& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kOk = 2,
    kError = 3,
    TYPE_NOT_SET = 0,
  };

  static inline const Output* internal_default_instance() {
    return reinterpret_cast<const Output*>(
               &_Output_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Output& a, Output& b) {
    a.Swap(&b);
  }
  inline void Swap(Output* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Output* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Output* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Output>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Output& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Output& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Output* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ArmoniK.api.grpc.v1.Output";
  }
  protected:
  explicit Output(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Output_Error Error;

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kOkFieldNumber = 2,
    kErrorFieldNumber = 3,
  };
  // .ArmoniK.api.grpc.v1.TaskStatus.TaskStatus status = 1;
  void clear_status();
  ::ArmoniK::api::grpc::v1::TaskStatus::TaskStatus status() const;
  void set_status(::ArmoniK::api::grpc::v1::TaskStatus::TaskStatus value);
  private:
  ::ArmoniK::api::grpc::v1::TaskStatus::TaskStatus _internal_status() const;
  void _internal_set_status(::ArmoniK::api::grpc::v1::TaskStatus::TaskStatus value);
  public:

  // .ArmoniK.api.grpc.v1.Empty ok = 2;
  bool has_ok() const;
  private:
  bool _internal_has_ok() const;
  public:
  void clear_ok();
  const ::ArmoniK::api::grpc::v1::Empty& ok() const;
  PROTOBUF_NODISCARD ::ArmoniK::api::grpc::v1::Empty* release_ok();
  ::ArmoniK::api::grpc::v1::Empty* mutable_ok();
  void set_allocated_ok(::ArmoniK::api::grpc::v1::Empty* ok);
  private:
  const ::ArmoniK::api::grpc::v1::Empty& _internal_ok() const;
  ::ArmoniK::api::grpc::v1::Empty* _internal_mutable_ok();
  public:
  void unsafe_arena_set_allocated_ok(
      ::ArmoniK::api::grpc::v1::Empty* ok);
  ::ArmoniK::api::grpc::v1::Empty* unsafe_arena_release_ok();

  // .ArmoniK.api.grpc.v1.Output.Error error = 3;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::ArmoniK::api::grpc::v1::Output_Error& error() const;
  PROTOBUF_NODISCARD ::ArmoniK::api::grpc::v1::Output_Error* release_error();
  ::ArmoniK::api::grpc::v1::Output_Error* mutable_error();
  void set_allocated_error(::ArmoniK::api::grpc::v1::Output_Error* error);
  private:
  const ::ArmoniK::api::grpc::v1::Output_Error& _internal_error() const;
  ::ArmoniK::api::grpc::v1::Output_Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::ArmoniK::api::grpc::v1::Output_Error* error);
  ::ArmoniK::api::grpc::v1::Output_Error* unsafe_arena_release_error();

  void clear_Type();
  TypeCase Type_case() const;
  // @@protoc_insertion_point(class_scope:ArmoniK.api.grpc.v1.Output)
 private:
  class _Internal;
  void set_has_ok();
  void set_has_error();

  inline bool has_Type() const;
  inline void clear_has_Type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int status_;
  union TypeUnion {
    constexpr TypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::ArmoniK::api::grpc::v1::Empty* ok_;
    ::ArmoniK::api::grpc::v1::Output_Error* error_;
  } Type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_objects_2eproto;
};
// -------------------------------------------------------------------

class TaskRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ArmoniK.api.grpc.v1.TaskRequest) */ {
 public:
  inline TaskRequest() : TaskRequest(nullptr) {}
  ~TaskRequest() override;
  explicit constexpr TaskRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskRequest(const TaskRequest& from);
  TaskRequest(TaskRequest&& from) noexcept
    : TaskRequest() {
    *this = ::std::move(from);
  }

  inline TaskRequest& operator=(const TaskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskRequest& operator=(TaskRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskRequest* internal_default_instance() {
    return reinterpret_cast<const TaskRequest*>(
               &_TaskRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TaskRequest& a, TaskRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TaskRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ArmoniK.api.grpc.v1.TaskRequest";
  }
  protected:
  explicit TaskRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExpectedOutputKeysFieldNumber = 2,
    kDataDependenciesFieldNumber = 3,
    kIdFieldNumber = 1,
    kPayloadFieldNumber = 4,
  };
  // repeated string expected_output_keys = 2;
  int expected_output_keys_size() const;
  private:
  int _internal_expected_output_keys_size() const;
  public:
  void clear_expected_output_keys();
  const std::string& expected_output_keys(int index) const;
  std::string* mutable_expected_output_keys(int index);
  void set_expected_output_keys(int index, const std::string& value);
  void set_expected_output_keys(int index, std::string&& value);
  void set_expected_output_keys(int index, const char* value);
  void set_expected_output_keys(int index, const char* value, size_t size);
  std::string* add_expected_output_keys();
  void add_expected_output_keys(const std::string& value);
  void add_expected_output_keys(std::string&& value);
  void add_expected_output_keys(const char* value);
  void add_expected_output_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& expected_output_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_expected_output_keys();
  private:
  const std::string& _internal_expected_output_keys(int index) const;
  std::string* _internal_add_expected_output_keys();
  public:

  // repeated string data_dependencies = 3;
  int data_dependencies_size() const;
  private:
  int _internal_data_dependencies_size() const;
  public:
  void clear_data_dependencies();
  const std::string& data_dependencies(int index) const;
  std::string* mutable_data_dependencies(int index);
  void set_data_dependencies(int index, const std::string& value);
  void set_data_dependencies(int index, std::string&& value);
  void set_data_dependencies(int index, const char* value);
  void set_data_dependencies(int index, const char* value, size_t size);
  std::string* add_data_dependencies();
  void add_data_dependencies(const std::string& value);
  void add_data_dependencies(std::string&& value);
  void add_data_dependencies(const char* value);
  void add_data_dependencies(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& data_dependencies() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_data_dependencies();
  private:
  const std::string& _internal_data_dependencies(int index) const;
  std::string* _internal_add_data_dependencies();
  public:

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // bytes payload = 4;
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // @@protoc_insertion_point(class_scope:ArmoniK.api.grpc.v1.TaskRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> expected_output_keys_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> data_dependencies_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_objects_2eproto;
};
// -------------------------------------------------------------------

class InitKeyedDataStream final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ArmoniK.api.grpc.v1.InitKeyedDataStream) */ {
 public:
  inline InitKeyedDataStream() : InitKeyedDataStream(nullptr) {}
  ~InitKeyedDataStream() override;
  explicit constexpr InitKeyedDataStream(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitKeyedDataStream(const InitKeyedDataStream& from);
  InitKeyedDataStream(InitKeyedDataStream&& from) noexcept
    : InitKeyedDataStream() {
    *this = ::std::move(from);
  }

  inline InitKeyedDataStream& operator=(const InitKeyedDataStream& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitKeyedDataStream& operator=(InitKeyedDataStream&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitKeyedDataStream& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kKey = 1,
    kLastResult = 2,
    TYPE_NOT_SET = 0,
  };

  static inline const InitKeyedDataStream* internal_default_instance() {
    return reinterpret_cast<const InitKeyedDataStream*>(
               &_InitKeyedDataStream_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(InitKeyedDataStream& a, InitKeyedDataStream& b) {
    a.Swap(&b);
  }
  inline void Swap(InitKeyedDataStream* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitKeyedDataStream* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitKeyedDataStream* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitKeyedDataStream>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InitKeyedDataStream& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InitKeyedDataStream& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitKeyedDataStream* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ArmoniK.api.grpc.v1.InitKeyedDataStream";
  }
  protected:
  explicit InitKeyedDataStream(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kLastResultFieldNumber = 2,
  };
  // string key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // bool last_result = 2;
  bool has_last_result() const;
  private:
  bool _internal_has_last_result() const;
  public:
  void clear_last_result();
  bool last_result() const;
  void set_last_result(bool value);
  private:
  bool _internal_last_result() const;
  void _internal_set_last_result(bool value);
  public:

  void clear_Type();
  TypeCase Type_case() const;
  // @@protoc_insertion_point(class_scope:ArmoniK.api.grpc.v1.InitKeyedDataStream)
 private:
  class _Internal;
  void set_has_key();
  void set_has_last_result();

  inline bool has_Type() const;
  inline void clear_has_Type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union TypeUnion {
    constexpr TypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    bool last_result_;
  } Type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_objects_2eproto;
};
// -------------------------------------------------------------------

class DataChunk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ArmoniK.api.grpc.v1.DataChunk) */ {
 public:
  inline DataChunk() : DataChunk(nullptr) {}
  ~DataChunk() override;
  explicit constexpr DataChunk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataChunk(const DataChunk& from);
  DataChunk(DataChunk&& from) noexcept
    : DataChunk() {
    *this = ::std::move(from);
  }

  inline DataChunk& operator=(const DataChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataChunk& operator=(DataChunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataChunk& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kData = 1,
    kDataComplete = 2,
    TYPE_NOT_SET = 0,
  };

  static inline const DataChunk* internal_default_instance() {
    return reinterpret_cast<const DataChunk*>(
               &_DataChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DataChunk& a, DataChunk& b) {
    a.Swap(&b);
  }
  inline void Swap(DataChunk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataChunk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataChunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataChunk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataChunk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DataChunk& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataChunk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ArmoniK.api.grpc.v1.DataChunk";
  }
  protected:
  explicit DataChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kDataCompleteFieldNumber = 2,
  };
  // bytes data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // bool dataComplete = 2;
  bool has_datacomplete() const;
  private:
  bool _internal_has_datacomplete() const;
  public:
  void clear_datacomplete();
  bool datacomplete() const;
  void set_datacomplete(bool value);
  private:
  bool _internal_datacomplete() const;
  void _internal_set_datacomplete(bool value);
  public:

  void clear_Type();
  TypeCase Type_case() const;
  // @@protoc_insertion_point(class_scope:ArmoniK.api.grpc.v1.DataChunk)
 private:
  class _Internal;
  void set_has_data();
  void set_has_datacomplete();

  inline bool has_Type() const;
  inline void clear_has_Type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union TypeUnion {
    constexpr TypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    bool datacomplete_;
  } Type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_objects_2eproto;
};
// -------------------------------------------------------------------

class TaskRequestHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ArmoniK.api.grpc.v1.TaskRequestHeader) */ {
 public:
  inline TaskRequestHeader() : TaskRequestHeader(nullptr) {}
  ~TaskRequestHeader() override;
  explicit constexpr TaskRequestHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskRequestHeader(const TaskRequestHeader& from);
  TaskRequestHeader(TaskRequestHeader&& from) noexcept
    : TaskRequestHeader() {
    *this = ::std::move(from);
  }

  inline TaskRequestHeader& operator=(const TaskRequestHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskRequestHeader& operator=(TaskRequestHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskRequestHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskRequestHeader* internal_default_instance() {
    return reinterpret_cast<const TaskRequestHeader*>(
               &_TaskRequestHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TaskRequestHeader& a, TaskRequestHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskRequestHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskRequestHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskRequestHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskRequestHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskRequestHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TaskRequestHeader& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskRequestHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ArmoniK.api.grpc.v1.TaskRequestHeader";
  }
  protected:
  explicit TaskRequestHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExpectedOutputKeysFieldNumber = 3,
    kDataDependenciesFieldNumber = 4,
    kIdFieldNumber = 1,
  };
  // repeated string expected_output_keys = 3;
  int expected_output_keys_size() const;
  private:
  int _internal_expected_output_keys_size() const;
  public:
  void clear_expected_output_keys();
  const std::string& expected_output_keys(int index) const;
  std::string* mutable_expected_output_keys(int index);
  void set_expected_output_keys(int index, const std::string& value);
  void set_expected_output_keys(int index, std::string&& value);
  void set_expected_output_keys(int index, const char* value);
  void set_expected_output_keys(int index, const char* value, size_t size);
  std::string* add_expected_output_keys();
  void add_expected_output_keys(const std::string& value);
  void add_expected_output_keys(std::string&& value);
  void add_expected_output_keys(const char* value);
  void add_expected_output_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& expected_output_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_expected_output_keys();
  private:
  const std::string& _internal_expected_output_keys(int index) const;
  std::string* _internal_add_expected_output_keys();
  public:

  // repeated string data_dependencies = 4;
  int data_dependencies_size() const;
  private:
  int _internal_data_dependencies_size() const;
  public:
  void clear_data_dependencies();
  const std::string& data_dependencies(int index) const;
  std::string* mutable_data_dependencies(int index);
  void set_data_dependencies(int index, const std::string& value);
  void set_data_dependencies(int index, std::string&& value);
  void set_data_dependencies(int index, const char* value);
  void set_data_dependencies(int index, const char* value, size_t size);
  std::string* add_data_dependencies();
  void add_data_dependencies(const std::string& value);
  void add_data_dependencies(std::string&& value);
  void add_data_dependencies(const char* value);
  void add_data_dependencies(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& data_dependencies() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_data_dependencies();
  private:
  const std::string& _internal_data_dependencies(int index) const;
  std::string* _internal_add_data_dependencies();
  public:

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:ArmoniK.api.grpc.v1.TaskRequestHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> expected_output_keys_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> data_dependencies_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_objects_2eproto;
};
// -------------------------------------------------------------------

class InitTaskRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ArmoniK.api.grpc.v1.InitTaskRequest) */ {
 public:
  inline InitTaskRequest() : InitTaskRequest(nullptr) {}
  ~InitTaskRequest() override;
  explicit constexpr InitTaskRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitTaskRequest(const InitTaskRequest& from);
  InitTaskRequest(InitTaskRequest&& from) noexcept
    : InitTaskRequest() {
    *this = ::std::move(from);
  }

  inline InitTaskRequest& operator=(const InitTaskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitTaskRequest& operator=(InitTaskRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitTaskRequest& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kHeader = 1,
    kLastTask = 2,
    TYPE_NOT_SET = 0,
  };

  static inline const InitTaskRequest* internal_default_instance() {
    return reinterpret_cast<const InitTaskRequest*>(
               &_InitTaskRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(InitTaskRequest& a, InitTaskRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InitTaskRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitTaskRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitTaskRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitTaskRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InitTaskRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InitTaskRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitTaskRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ArmoniK.api.grpc.v1.InitTaskRequest";
  }
  protected:
  explicit InitTaskRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLastTaskFieldNumber = 2,
  };
  // .ArmoniK.api.grpc.v1.TaskRequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::ArmoniK::api::grpc::v1::TaskRequestHeader& header() const;
  PROTOBUF_NODISCARD ::ArmoniK::api::grpc::v1::TaskRequestHeader* release_header();
  ::ArmoniK::api::grpc::v1::TaskRequestHeader* mutable_header();
  void set_allocated_header(::ArmoniK::api::grpc::v1::TaskRequestHeader* header);
  private:
  const ::ArmoniK::api::grpc::v1::TaskRequestHeader& _internal_header() const;
  ::ArmoniK::api::grpc::v1::TaskRequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::ArmoniK::api::grpc::v1::TaskRequestHeader* header);
  ::ArmoniK::api::grpc::v1::TaskRequestHeader* unsafe_arena_release_header();

  // bool last_task = 2;
  bool has_last_task() const;
  private:
  bool _internal_has_last_task() const;
  public:
  void clear_last_task();
  bool last_task() const;
  void set_last_task(bool value);
  private:
  bool _internal_last_task() const;
  void _internal_set_last_task(bool value);
  public:

  void clear_Type();
  TypeCase Type_case() const;
  // @@protoc_insertion_point(class_scope:ArmoniK.api.grpc.v1.InitTaskRequest)
 private:
  class _Internal;
  void set_has_header();
  void set_has_last_task();

  inline bool has_Type() const;
  inline void clear_has_Type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union TypeUnion {
    constexpr TypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::ArmoniK::api::grpc::v1::TaskRequestHeader* header_;
    bool last_task_;
  } Type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_objects_2eproto;
};
// -------------------------------------------------------------------

class TaskId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ArmoniK.api.grpc.v1.TaskId) */ {
 public:
  inline TaskId() : TaskId(nullptr) {}
  ~TaskId() override;
  explicit constexpr TaskId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskId(const TaskId& from);
  TaskId(TaskId&& from) noexcept
    : TaskId() {
    *this = ::std::move(from);
  }

  inline TaskId& operator=(const TaskId& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskId& operator=(TaskId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskId& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskId* internal_default_instance() {
    return reinterpret_cast<const TaskId*>(
               &_TaskId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TaskId& a, TaskId& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TaskId& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ArmoniK.api.grpc.v1.TaskId";
  }
  protected:
  explicit TaskId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionFieldNumber = 1,
    kTaskFieldNumber = 2,
  };
  // string session = 1;
  void clear_session();
  const std::string& session() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session();
  PROTOBUF_NODISCARD std::string* release_session();
  void set_allocated_session(std::string* session);
  private:
  const std::string& _internal_session() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session(const std::string& value);
  std::string* _internal_mutable_session();
  public:

  // string task = 2;
  void clear_task();
  const std::string& task() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task();
  PROTOBUF_NODISCARD std::string* release_task();
  void set_allocated_task(std::string* task);
  private:
  const std::string& _internal_task() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task(const std::string& value);
  std::string* _internal_mutable_task();
  public:

  // @@protoc_insertion_point(class_scope:ArmoniK.api.grpc.v1.TaskId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_objects_2eproto;
};
// -------------------------------------------------------------------

class TaskIdList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ArmoniK.api.grpc.v1.TaskIdList) */ {
 public:
  inline TaskIdList() : TaskIdList(nullptr) {}
  ~TaskIdList() override;
  explicit constexpr TaskIdList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskIdList(const TaskIdList& from);
  TaskIdList(TaskIdList&& from) noexcept
    : TaskIdList() {
    *this = ::std::move(from);
  }

  inline TaskIdList& operator=(const TaskIdList& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskIdList& operator=(TaskIdList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskIdList& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskIdList* internal_default_instance() {
    return reinterpret_cast<const TaskIdList*>(
               &_TaskIdList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TaskIdList& a, TaskIdList& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskIdList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskIdList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskIdList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskIdList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskIdList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TaskIdList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskIdList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ArmoniK.api.grpc.v1.TaskIdList";
  }
  protected:
  explicit TaskIdList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskIdsFieldNumber = 1,
  };
  // repeated string task_ids = 1;
  int task_ids_size() const;
  private:
  int _internal_task_ids_size() const;
  public:
  void clear_task_ids();
  const std::string& task_ids(int index) const;
  std::string* mutable_task_ids(int index);
  void set_task_ids(int index, const std::string& value);
  void set_task_ids(int index, std::string&& value);
  void set_task_ids(int index, const char* value);
  void set_task_ids(int index, const char* value, size_t size);
  std::string* add_task_ids();
  void add_task_ids(const std::string& value);
  void add_task_ids(std::string&& value);
  void add_task_ids(const char* value);
  void add_task_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& task_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_task_ids();
  private:
  const std::string& _internal_task_ids(int index) const;
  std::string* _internal_add_task_ids();
  public:

  // @@protoc_insertion_point(class_scope:ArmoniK.api.grpc.v1.TaskIdList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> task_ids_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_objects_2eproto;
};
// -------------------------------------------------------------------

class StatusCount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ArmoniK.api.grpc.v1.StatusCount) */ {
 public:
  inline StatusCount() : StatusCount(nullptr) {}
  ~StatusCount() override;
  explicit constexpr StatusCount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatusCount(const StatusCount& from);
  StatusCount(StatusCount&& from) noexcept
    : StatusCount() {
    *this = ::std::move(from);
  }

  inline StatusCount& operator=(const StatusCount& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusCount& operator=(StatusCount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusCount& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatusCount* internal_default_instance() {
    return reinterpret_cast<const StatusCount*>(
               &_StatusCount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(StatusCount& a, StatusCount& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusCount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusCount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatusCount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatusCount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatusCount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StatusCount& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusCount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ArmoniK.api.grpc.v1.StatusCount";
  }
  protected:
  explicit StatusCount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kCountFieldNumber = 2,
  };
  // .ArmoniK.api.grpc.v1.TaskStatus.TaskStatus status = 1;
  void clear_status();
  ::ArmoniK::api::grpc::v1::TaskStatus::TaskStatus status() const;
  void set_status(::ArmoniK::api::grpc::v1::TaskStatus::TaskStatus value);
  private:
  ::ArmoniK::api::grpc::v1::TaskStatus::TaskStatus _internal_status() const;
  void _internal_set_status(::ArmoniK::api::grpc::v1::TaskStatus::TaskStatus value);
  public:

  // int32 count = 2;
  void clear_count();
  int32_t count() const;
  void set_count(int32_t value);
  private:
  int32_t _internal_count() const;
  void _internal_set_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ArmoniK.api.grpc.v1.StatusCount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int status_;
  int32_t count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_objects_2eproto;
};
// -------------------------------------------------------------------

class Count final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ArmoniK.api.grpc.v1.Count) */ {
 public:
  inline Count() : Count(nullptr) {}
  ~Count() override;
  explicit constexpr Count(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Count(const Count& from);
  Count(Count&& from) noexcept
    : Count() {
    *this = ::std::move(from);
  }

  inline Count& operator=(const Count& from) {
    CopyFrom(from);
    return *this;
  }
  inline Count& operator=(Count&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Count& default_instance() {
    return *internal_default_instance();
  }
  static inline const Count* internal_default_instance() {
    return reinterpret_cast<const Count*>(
               &_Count_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Count& a, Count& b) {
    a.Swap(&b);
  }
  inline void Swap(Count* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Count* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Count* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Count>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Count& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Count& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Count* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ArmoniK.api.grpc.v1.Count";
  }
  protected:
  explicit Count(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated .ArmoniK.api.grpc.v1.StatusCount values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  ::ArmoniK::api::grpc::v1::StatusCount* mutable_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ArmoniK::api::grpc::v1::StatusCount >*
      mutable_values();
  private:
  const ::ArmoniK::api::grpc::v1::StatusCount& _internal_values(int index) const;
  ::ArmoniK::api::grpc::v1::StatusCount* _internal_add_values();
  public:
  const ::ArmoniK::api::grpc::v1::StatusCount& values(int index) const;
  ::ArmoniK::api::grpc::v1::StatusCount* add_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ArmoniK::api::grpc::v1::StatusCount >&
      values() const;

  // @@protoc_insertion_point(class_scope:ArmoniK.api.grpc.v1.Count)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ArmoniK::api::grpc::v1::StatusCount > values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_objects_2eproto;
};
// -------------------------------------------------------------------

class ResultRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ArmoniK.api.grpc.v1.ResultRequest) */ {
 public:
  inline ResultRequest() : ResultRequest(nullptr) {}
  ~ResultRequest() override;
  explicit constexpr ResultRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResultRequest(const ResultRequest& from);
  ResultRequest(ResultRequest&& from) noexcept
    : ResultRequest() {
    *this = ::std::move(from);
  }

  inline ResultRequest& operator=(const ResultRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResultRequest& operator=(ResultRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResultRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResultRequest* internal_default_instance() {
    return reinterpret_cast<const ResultRequest*>(
               &_ResultRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ResultRequest& a, ResultRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ResultRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResultRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResultRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResultRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResultRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResultRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResultRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ArmoniK.api.grpc.v1.ResultRequest";
  }
  protected:
  explicit ResultRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionFieldNumber = 1,
    kKeyFieldNumber = 2,
  };
  // string session = 1;
  void clear_session();
  const std::string& session() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session();
  PROTOBUF_NODISCARD std::string* release_session();
  void set_allocated_session(std::string* session);
  private:
  const std::string& _internal_session() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session(const std::string& value);
  std::string* _internal_mutable_session();
  public:

  // string key = 2;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // @@protoc_insertion_point(class_scope:ArmoniK.api.grpc.v1.ResultRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_objects_2eproto;
};
// -------------------------------------------------------------------

class Error final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ArmoniK.api.grpc.v1.Error) */ {
 public:
  inline Error() : Error(nullptr) {}
  ~Error() override;
  explicit constexpr Error(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Error(const Error& from);
  Error(Error&& from) noexcept
    : Error() {
    *this = ::std::move(from);
  }

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  inline Error& operator=(Error&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Error& default_instance() {
    return *internal_default_instance();
  }
  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Error& a, Error& b) {
    a.Swap(&b);
  }
  inline void Swap(Error* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Error* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Error* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Error>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Error& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Error& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Error* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ArmoniK.api.grpc.v1.Error";
  }
  protected:
  explicit Error(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDetailFieldNumber = 2,
    kTaskStatusFieldNumber = 1,
  };
  // string detail = 2;
  void clear_detail();
  const std::string& detail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_detail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_detail();
  PROTOBUF_NODISCARD std::string* release_detail();
  void set_allocated_detail(std::string* detail);
  private:
  const std::string& _internal_detail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_detail(const std::string& value);
  std::string* _internal_mutable_detail();
  public:

  // .ArmoniK.api.grpc.v1.TaskStatus.TaskStatus task_status = 1;
  void clear_task_status();
  ::ArmoniK::api::grpc::v1::TaskStatus::TaskStatus task_status() const;
  void set_task_status(::ArmoniK::api::grpc::v1::TaskStatus::TaskStatus value);
  private:
  ::ArmoniK::api::grpc::v1::TaskStatus::TaskStatus _internal_task_status() const;
  void _internal_set_task_status(::ArmoniK::api::grpc::v1::TaskStatus::TaskStatus value);
  public:

  // @@protoc_insertion_point(class_scope:ArmoniK.api.grpc.v1.Error)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr detail_;
  int task_status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_objects_2eproto;
};
// -------------------------------------------------------------------

class TaskError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ArmoniK.api.grpc.v1.TaskError) */ {
 public:
  inline TaskError() : TaskError(nullptr) {}
  ~TaskError() override;
  explicit constexpr TaskError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskError(const TaskError& from);
  TaskError(TaskError&& from) noexcept
    : TaskError() {
    *this = ::std::move(from);
  }

  inline TaskError& operator=(const TaskError& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskError& operator=(TaskError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskError& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskError* internal_default_instance() {
    return reinterpret_cast<const TaskError*>(
               &_TaskError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(TaskError& a, TaskError& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskError* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TaskError& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskError* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ArmoniK.api.grpc.v1.TaskError";
  }
  protected:
  explicit TaskError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kTaskIdFieldNumber = 1,
  };
  // repeated .ArmoniK.api.grpc.v1.Error error = 2;
  int error_size() const;
  private:
  int _internal_error_size() const;
  public:
  void clear_error();
  ::ArmoniK::api::grpc::v1::Error* mutable_error(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ArmoniK::api::grpc::v1::Error >*
      mutable_error();
  private:
  const ::ArmoniK::api::grpc::v1::Error& _internal_error(int index) const;
  ::ArmoniK::api::grpc::v1::Error* _internal_add_error();
  public:
  const ::ArmoniK::api::grpc::v1::Error& error(int index) const;
  ::ArmoniK::api::grpc::v1::Error* add_error();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ArmoniK::api::grpc::v1::Error >&
      error() const;

  // string task_id = 1;
  void clear_task_id();
  const std::string& task_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task_id();
  PROTOBUF_NODISCARD std::string* release_task_id();
  void set_allocated_task_id(std::string* task_id);
  private:
  const std::string& _internal_task_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_id(const std::string& value);
  std::string* _internal_mutable_task_id();
  public:

  // @@protoc_insertion_point(class_scope:ArmoniK.api.grpc.v1.TaskError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ArmoniK::api::grpc::v1::Error > error_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_objects_2eproto;
};
// -------------------------------------------------------------------

class CreateTaskReply_TaskIds final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ArmoniK.api.grpc.v1.CreateTaskReply.TaskIds) */ {
 public:
  inline CreateTaskReply_TaskIds() : CreateTaskReply_TaskIds(nullptr) {}
  ~CreateTaskReply_TaskIds() override;
  explicit constexpr CreateTaskReply_TaskIds(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateTaskReply_TaskIds(const CreateTaskReply_TaskIds& from);
  CreateTaskReply_TaskIds(CreateTaskReply_TaskIds&& from) noexcept
    : CreateTaskReply_TaskIds() {
    *this = ::std::move(from);
  }

  inline CreateTaskReply_TaskIds& operator=(const CreateTaskReply_TaskIds& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTaskReply_TaskIds& operator=(CreateTaskReply_TaskIds&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateTaskReply_TaskIds& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateTaskReply_TaskIds* internal_default_instance() {
    return reinterpret_cast<const CreateTaskReply_TaskIds*>(
               &_CreateTaskReply_TaskIds_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(CreateTaskReply_TaskIds& a, CreateTaskReply_TaskIds& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateTaskReply_TaskIds* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTaskReply_TaskIds* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateTaskReply_TaskIds* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateTaskReply_TaskIds>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateTaskReply_TaskIds& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateTaskReply_TaskIds& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTaskReply_TaskIds* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ArmoniK.api.grpc.v1.CreateTaskReply.TaskIds";
  }
  protected:
  explicit CreateTaskReply_TaskIds(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdsFieldNumber = 1,
  };
  // repeated string ids = 1;
  int ids_size() const;
  private:
  int _internal_ids_size() const;
  public:
  void clear_ids();
  const std::string& ids(int index) const;
  std::string* mutable_ids(int index);
  void set_ids(int index, const std::string& value);
  void set_ids(int index, std::string&& value);
  void set_ids(int index, const char* value);
  void set_ids(int index, const char* value, size_t size);
  std::string* add_ids();
  void add_ids(const std::string& value);
  void add_ids(std::string&& value);
  void add_ids(const char* value);
  void add_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_ids();
  private:
  const std::string& _internal_ids(int index) const;
  std::string* _internal_add_ids();
  public:

  // @@protoc_insertion_point(class_scope:ArmoniK.api.grpc.v1.CreateTaskReply.TaskIds)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> ids_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_objects_2eproto;
};
// -------------------------------------------------------------------

class CreateTaskReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ArmoniK.api.grpc.v1.CreateTaskReply) */ {
 public:
  inline CreateTaskReply() : CreateTaskReply(nullptr) {}
  ~CreateTaskReply() override;
  explicit constexpr CreateTaskReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateTaskReply(const CreateTaskReply& from);
  CreateTaskReply(CreateTaskReply&& from) noexcept
    : CreateTaskReply() {
    *this = ::std::move(from);
  }

  inline CreateTaskReply& operator=(const CreateTaskReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTaskReply& operator=(CreateTaskReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateTaskReply& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kSuccessfull = 1,
    kNonSuccessfullIds = 2,
    DATA_NOT_SET = 0,
  };

  static inline const CreateTaskReply* internal_default_instance() {
    return reinterpret_cast<const CreateTaskReply*>(
               &_CreateTaskReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(CreateTaskReply& a, CreateTaskReply& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateTaskReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTaskReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateTaskReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateTaskReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateTaskReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateTaskReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTaskReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ArmoniK.api.grpc.v1.CreateTaskReply";
  }
  protected:
  explicit CreateTaskReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CreateTaskReply_TaskIds TaskIds;

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessfullFieldNumber = 1,
    kNonSuccessfullIdsFieldNumber = 2,
  };
  // .ArmoniK.api.grpc.v1.Empty successfull = 1;
  bool has_successfull() const;
  private:
  bool _internal_has_successfull() const;
  public:
  void clear_successfull();
  const ::ArmoniK::api::grpc::v1::Empty& successfull() const;
  PROTOBUF_NODISCARD ::ArmoniK::api::grpc::v1::Empty* release_successfull();
  ::ArmoniK::api::grpc::v1::Empty* mutable_successfull();
  void set_allocated_successfull(::ArmoniK::api::grpc::v1::Empty* successfull);
  private:
  const ::ArmoniK::api::grpc::v1::Empty& _internal_successfull() const;
  ::ArmoniK::api::grpc::v1::Empty* _internal_mutable_successfull();
  public:
  void unsafe_arena_set_allocated_successfull(
      ::ArmoniK::api::grpc::v1::Empty* successfull);
  ::ArmoniK::api::grpc::v1::Empty* unsafe_arena_release_successfull();

  // .ArmoniK.api.grpc.v1.CreateTaskReply.TaskIds non_successfull_ids = 2;
  bool has_non_successfull_ids() const;
  private:
  bool _internal_has_non_successfull_ids() const;
  public:
  void clear_non_successfull_ids();
  const ::ArmoniK::api::grpc::v1::CreateTaskReply_TaskIds& non_successfull_ids() const;
  PROTOBUF_NODISCARD ::ArmoniK::api::grpc::v1::CreateTaskReply_TaskIds* release_non_successfull_ids();
  ::ArmoniK::api::grpc::v1::CreateTaskReply_TaskIds* mutable_non_successfull_ids();
  void set_allocated_non_successfull_ids(::ArmoniK::api::grpc::v1::CreateTaskReply_TaskIds* non_successfull_ids);
  private:
  const ::ArmoniK::api::grpc::v1::CreateTaskReply_TaskIds& _internal_non_successfull_ids() const;
  ::ArmoniK::api::grpc::v1::CreateTaskReply_TaskIds* _internal_mutable_non_successfull_ids();
  public:
  void unsafe_arena_set_allocated_non_successfull_ids(
      ::ArmoniK::api::grpc::v1::CreateTaskReply_TaskIds* non_successfull_ids);
  ::ArmoniK::api::grpc::v1::CreateTaskReply_TaskIds* unsafe_arena_release_non_successfull_ids();

  void clear_Data();
  DataCase Data_case() const;
  // @@protoc_insertion_point(class_scope:ArmoniK.api.grpc.v1.CreateTaskReply)
 private:
  class _Internal;
  void set_has_successfull();
  void set_has_non_successfull_ids();

  inline bool has_Data() const;
  inline void clear_has_Data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union DataUnion {
    constexpr DataUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::ArmoniK::api::grpc::v1::Empty* successfull_;
    ::ArmoniK::api::grpc::v1::CreateTaskReply_TaskIds* non_successfull_ids_;
  } Data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_objects_2eproto;
};
// -------------------------------------------------------------------

class TaskList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ArmoniK.api.grpc.v1.TaskList) */ {
 public:
  inline TaskList() : TaskList(nullptr) {}
  ~TaskList() override;
  explicit constexpr TaskList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskList(const TaskList& from);
  TaskList(TaskList&& from) noexcept
    : TaskList() {
    *this = ::std::move(from);
  }

  inline TaskList& operator=(const TaskList& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskList& operator=(TaskList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskList& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskList* internal_default_instance() {
    return reinterpret_cast<const TaskList*>(
               &_TaskList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(TaskList& a, TaskList& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TaskList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ArmoniK.api.grpc.v1.TaskList";
  }
  protected:
  explicit TaskList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskIdsFieldNumber = 1,
  };
  // repeated .ArmoniK.api.grpc.v1.TaskId taskIds = 1;
  int taskids_size() const;
  private:
  int _internal_taskids_size() const;
  public:
  void clear_taskids();
  ::ArmoniK::api::grpc::v1::TaskId* mutable_taskids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ArmoniK::api::grpc::v1::TaskId >*
      mutable_taskids();
  private:
  const ::ArmoniK::api::grpc::v1::TaskId& _internal_taskids(int index) const;
  ::ArmoniK::api::grpc::v1::TaskId* _internal_add_taskids();
  public:
  const ::ArmoniK::api::grpc::v1::TaskId& taskids(int index) const;
  ::ArmoniK::api::grpc::v1::TaskId* add_taskids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ArmoniK::api::grpc::v1::TaskId >&
      taskids() const;

  // @@protoc_insertion_point(class_scope:ArmoniK.api.grpc.v1.TaskList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ArmoniK::api::grpc::v1::TaskId > taskids_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_objects_2eproto;
};
// -------------------------------------------------------------------

class TaskIdWithStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ArmoniK.api.grpc.v1.TaskIdWithStatus) */ {
 public:
  inline TaskIdWithStatus() : TaskIdWithStatus(nullptr) {}
  ~TaskIdWithStatus() override;
  explicit constexpr TaskIdWithStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskIdWithStatus(const TaskIdWithStatus& from);
  TaskIdWithStatus(TaskIdWithStatus&& from) noexcept
    : TaskIdWithStatus() {
    *this = ::std::move(from);
  }

  inline TaskIdWithStatus& operator=(const TaskIdWithStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskIdWithStatus& operator=(TaskIdWithStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskIdWithStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskIdWithStatus* internal_default_instance() {
    return reinterpret_cast<const TaskIdWithStatus*>(
               &_TaskIdWithStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(TaskIdWithStatus& a, TaskIdWithStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskIdWithStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskIdWithStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskIdWithStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskIdWithStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskIdWithStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TaskIdWithStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskIdWithStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ArmoniK.api.grpc.v1.TaskIdWithStatus";
  }
  protected:
  explicit TaskIdWithStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskIdFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // .ArmoniK.api.grpc.v1.TaskId TaskId = 1;
  bool has_taskid() const;
  private:
  bool _internal_has_taskid() const;
  public:
  void clear_taskid();
  const ::ArmoniK::api::grpc::v1::TaskId& taskid() const;
  PROTOBUF_NODISCARD ::ArmoniK::api::grpc::v1::TaskId* release_taskid();
  ::ArmoniK::api::grpc::v1::TaskId* mutable_taskid();
  void set_allocated_taskid(::ArmoniK::api::grpc::v1::TaskId* taskid);
  private:
  const ::ArmoniK::api::grpc::v1::TaskId& _internal_taskid() const;
  ::ArmoniK::api::grpc::v1::TaskId* _internal_mutable_taskid();
  public:
  void unsafe_arena_set_allocated_taskid(
      ::ArmoniK::api::grpc::v1::TaskId* taskid);
  ::ArmoniK::api::grpc::v1::TaskId* unsafe_arena_release_taskid();

  // .ArmoniK.api.grpc.v1.TaskStatus.TaskStatus Status = 2;
  void clear_status();
  ::ArmoniK::api::grpc::v1::TaskStatus::TaskStatus status() const;
  void set_status(::ArmoniK::api::grpc::v1::TaskStatus::TaskStatus value);
  private:
  ::ArmoniK::api::grpc::v1::TaskStatus::TaskStatus _internal_status() const;
  void _internal_set_status(::ArmoniK::api::grpc::v1::TaskStatus::TaskStatus value);
  public:

  // @@protoc_insertion_point(class_scope:ArmoniK.api.grpc.v1.TaskIdWithStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::ArmoniK::api::grpc::v1::TaskId* taskid_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_objects_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Empty

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TaskOptions

// map<string, string> Options = 1;
inline int TaskOptions::_internal_options_size() const {
  return options_.size();
}
inline int TaskOptions::options_size() const {
  return _internal_options_size();
}
inline void TaskOptions::clear_options() {
  options_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TaskOptions::_internal_options() const {
  return options_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TaskOptions::options() const {
  // @@protoc_insertion_point(field_map:ArmoniK.api.grpc.v1.TaskOptions.Options)
  return _internal_options();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TaskOptions::_internal_mutable_options() {
  return options_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TaskOptions::mutable_options() {
  // @@protoc_insertion_point(field_mutable_map:ArmoniK.api.grpc.v1.TaskOptions.Options)
  return _internal_mutable_options();
}

// .google.protobuf.Duration MaxDuration = 2;
inline bool TaskOptions::_internal_has_maxduration() const {
  return this != internal_default_instance() && maxduration_ != nullptr;
}
inline bool TaskOptions::has_maxduration() const {
  return _internal_has_maxduration();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& TaskOptions::_internal_maxduration() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = maxduration_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& TaskOptions::maxduration() const {
  // @@protoc_insertion_point(field_get:ArmoniK.api.grpc.v1.TaskOptions.MaxDuration)
  return _internal_maxduration();
}
inline void TaskOptions::unsafe_arena_set_allocated_maxduration(
    ::PROTOBUF_NAMESPACE_ID::Duration* maxduration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(maxduration_);
  }
  maxduration_ = maxduration;
  if (maxduration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ArmoniK.api.grpc.v1.TaskOptions.MaxDuration)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* TaskOptions::release_maxduration() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = maxduration_;
  maxduration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* TaskOptions::unsafe_arena_release_maxduration() {
  // @@protoc_insertion_point(field_release:ArmoniK.api.grpc.v1.TaskOptions.MaxDuration)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = maxduration_;
  maxduration_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* TaskOptions::_internal_mutable_maxduration() {
  
  if (maxduration_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    maxduration_ = p;
  }
  return maxduration_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* TaskOptions::mutable_maxduration() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_maxduration();
  // @@protoc_insertion_point(field_mutable:ArmoniK.api.grpc.v1.TaskOptions.MaxDuration)
  return _msg;
}
inline void TaskOptions::set_allocated_maxduration(::PROTOBUF_NAMESPACE_ID::Duration* maxduration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(maxduration_);
  }
  if (maxduration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(maxduration));
    if (message_arena != submessage_arena) {
      maxduration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, maxduration, submessage_arena);
    }
    
  } else {
    
  }
  maxduration_ = maxduration;
  // @@protoc_insertion_point(field_set_allocated:ArmoniK.api.grpc.v1.TaskOptions.MaxDuration)
}

// int32 MaxRetries = 3;
inline void TaskOptions::clear_maxretries() {
  maxretries_ = 0;
}
inline int32_t TaskOptions::_internal_maxretries() const {
  return maxretries_;
}
inline int32_t TaskOptions::maxretries() const {
  // @@protoc_insertion_point(field_get:ArmoniK.api.grpc.v1.TaskOptions.MaxRetries)
  return _internal_maxretries();
}
inline void TaskOptions::_internal_set_maxretries(int32_t value) {
  
  maxretries_ = value;
}
inline void TaskOptions::set_maxretries(int32_t value) {
  _internal_set_maxretries(value);
  // @@protoc_insertion_point(field_set:ArmoniK.api.grpc.v1.TaskOptions.MaxRetries)
}

// int32 Priority = 4;
inline void TaskOptions::clear_priority() {
  priority_ = 0;
}
inline int32_t TaskOptions::_internal_priority() const {
  return priority_;
}
inline int32_t TaskOptions::priority() const {
  // @@protoc_insertion_point(field_get:ArmoniK.api.grpc.v1.TaskOptions.Priority)
  return _internal_priority();
}
inline void TaskOptions::_internal_set_priority(int32_t value) {
  
  priority_ = value;
}
inline void TaskOptions::set_priority(int32_t value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:ArmoniK.api.grpc.v1.TaskOptions.Priority)
}

// -------------------------------------------------------------------

// Configuration

// int32 data_chunk_max_size = 1;
inline void Configuration::clear_data_chunk_max_size() {
  data_chunk_max_size_ = 0;
}
inline int32_t Configuration::_internal_data_chunk_max_size() const {
  return data_chunk_max_size_;
}
inline int32_t Configuration::data_chunk_max_size() const {
  // @@protoc_insertion_point(field_get:ArmoniK.api.grpc.v1.Configuration.data_chunk_max_size)
  return _internal_data_chunk_max_size();
}
inline void Configuration::_internal_set_data_chunk_max_size(int32_t value) {
  
  data_chunk_max_size_ = value;
}
inline void Configuration::set_data_chunk_max_size(int32_t value) {
  _internal_set_data_chunk_max_size(value);
  // @@protoc_insertion_point(field_set:ArmoniK.api.grpc.v1.Configuration.data_chunk_max_size)
}

// -------------------------------------------------------------------

// Output_Error

// string details = 1;
inline void Output_Error::clear_details() {
  details_.ClearToEmpty();
}
inline const std::string& Output_Error::details() const {
  // @@protoc_insertion_point(field_get:ArmoniK.api.grpc.v1.Output.Error.details)
  return _internal_details();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Output_Error::set_details(ArgT0&& arg0, ArgT... args) {
 
 details_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ArmoniK.api.grpc.v1.Output.Error.details)
}
inline std::string* Output_Error::mutable_details() {
  std::string* _s = _internal_mutable_details();
  // @@protoc_insertion_point(field_mutable:ArmoniK.api.grpc.v1.Output.Error.details)
  return _s;
}
inline const std::string& Output_Error::_internal_details() const {
  return details_.Get();
}
inline void Output_Error::_internal_set_details(const std::string& value) {
  
  details_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Output_Error::_internal_mutable_details() {
  
  return details_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Output_Error::release_details() {
  // @@protoc_insertion_point(field_release:ArmoniK.api.grpc.v1.Output.Error.details)
  return details_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Output_Error::set_allocated_details(std::string* details) {
  if (details != nullptr) {
    
  } else {
    
  }
  details_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), details,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (details_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    details_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ArmoniK.api.grpc.v1.Output.Error.details)
}

// bool kill_sub_tasks = 2;
inline void Output_Error::clear_kill_sub_tasks() {
  kill_sub_tasks_ = false;
}
inline bool Output_Error::_internal_kill_sub_tasks() const {
  return kill_sub_tasks_;
}
inline bool Output_Error::kill_sub_tasks() const {
  // @@protoc_insertion_point(field_get:ArmoniK.api.grpc.v1.Output.Error.kill_sub_tasks)
  return _internal_kill_sub_tasks();
}
inline void Output_Error::_internal_set_kill_sub_tasks(bool value) {
  
  kill_sub_tasks_ = value;
}
inline void Output_Error::set_kill_sub_tasks(bool value) {
  _internal_set_kill_sub_tasks(value);
  // @@protoc_insertion_point(field_set:ArmoniK.api.grpc.v1.Output.Error.kill_sub_tasks)
}

// -------------------------------------------------------------------

// Output

// .ArmoniK.api.grpc.v1.TaskStatus.TaskStatus status = 1;
inline void Output::clear_status() {
  status_ = 0;
}
inline ::ArmoniK::api::grpc::v1::TaskStatus::TaskStatus Output::_internal_status() const {
  return static_cast< ::ArmoniK::api::grpc::v1::TaskStatus::TaskStatus >(status_);
}
inline ::ArmoniK::api::grpc::v1::TaskStatus::TaskStatus Output::status() const {
  // @@protoc_insertion_point(field_get:ArmoniK.api.grpc.v1.Output.status)
  return _internal_status();
}
inline void Output::_internal_set_status(::ArmoniK::api::grpc::v1::TaskStatus::TaskStatus value) {
  
  status_ = value;
}
inline void Output::set_status(::ArmoniK::api::grpc::v1::TaskStatus::TaskStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:ArmoniK.api.grpc.v1.Output.status)
}

// .ArmoniK.api.grpc.v1.Empty ok = 2;
inline bool Output::_internal_has_ok() const {
  return Type_case() == kOk;
}
inline bool Output::has_ok() const {
  return _internal_has_ok();
}
inline void Output::set_has_ok() {
  _oneof_case_[0] = kOk;
}
inline void Output::clear_ok() {
  if (_internal_has_ok()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.ok_;
    }
    clear_has_Type();
  }
}
inline ::ArmoniK::api::grpc::v1::Empty* Output::release_ok() {
  // @@protoc_insertion_point(field_release:ArmoniK.api.grpc.v1.Output.ok)
  if (_internal_has_ok()) {
    clear_has_Type();
      ::ArmoniK::api::grpc::v1::Empty* temp = Type_.ok_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.ok_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ArmoniK::api::grpc::v1::Empty& Output::_internal_ok() const {
  return _internal_has_ok()
      ? *Type_.ok_
      : reinterpret_cast< ::ArmoniK::api::grpc::v1::Empty&>(::ArmoniK::api::grpc::v1::_Empty_default_instance_);
}
inline const ::ArmoniK::api::grpc::v1::Empty& Output::ok() const {
  // @@protoc_insertion_point(field_get:ArmoniK.api.grpc.v1.Output.ok)
  return _internal_ok();
}
inline ::ArmoniK::api::grpc::v1::Empty* Output::unsafe_arena_release_ok() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ArmoniK.api.grpc.v1.Output.ok)
  if (_internal_has_ok()) {
    clear_has_Type();
    ::ArmoniK::api::grpc::v1::Empty* temp = Type_.ok_;
    Type_.ok_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Output::unsafe_arena_set_allocated_ok(::ArmoniK::api::grpc::v1::Empty* ok) {
  clear_Type();
  if (ok) {
    set_has_ok();
    Type_.ok_ = ok;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ArmoniK.api.grpc.v1.Output.ok)
}
inline ::ArmoniK::api::grpc::v1::Empty* Output::_internal_mutable_ok() {
  if (!_internal_has_ok()) {
    clear_Type();
    set_has_ok();
    Type_.ok_ = CreateMaybeMessage< ::ArmoniK::api::grpc::v1::Empty >(GetArenaForAllocation());
  }
  return Type_.ok_;
}
inline ::ArmoniK::api::grpc::v1::Empty* Output::mutable_ok() {
  ::ArmoniK::api::grpc::v1::Empty* _msg = _internal_mutable_ok();
  // @@protoc_insertion_point(field_mutable:ArmoniK.api.grpc.v1.Output.ok)
  return _msg;
}

// .ArmoniK.api.grpc.v1.Output.Error error = 3;
inline bool Output::_internal_has_error() const {
  return Type_case() == kError;
}
inline bool Output::has_error() const {
  return _internal_has_error();
}
inline void Output::set_has_error() {
  _oneof_case_[0] = kError;
}
inline void Output::clear_error() {
  if (_internal_has_error()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.error_;
    }
    clear_has_Type();
  }
}
inline ::ArmoniK::api::grpc::v1::Output_Error* Output::release_error() {
  // @@protoc_insertion_point(field_release:ArmoniK.api.grpc.v1.Output.error)
  if (_internal_has_error()) {
    clear_has_Type();
      ::ArmoniK::api::grpc::v1::Output_Error* temp = Type_.error_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ArmoniK::api::grpc::v1::Output_Error& Output::_internal_error() const {
  return _internal_has_error()
      ? *Type_.error_
      : reinterpret_cast< ::ArmoniK::api::grpc::v1::Output_Error&>(::ArmoniK::api::grpc::v1::_Output_Error_default_instance_);
}
inline const ::ArmoniK::api::grpc::v1::Output_Error& Output::error() const {
  // @@protoc_insertion_point(field_get:ArmoniK.api.grpc.v1.Output.error)
  return _internal_error();
}
inline ::ArmoniK::api::grpc::v1::Output_Error* Output::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ArmoniK.api.grpc.v1.Output.error)
  if (_internal_has_error()) {
    clear_has_Type();
    ::ArmoniK::api::grpc::v1::Output_Error* temp = Type_.error_;
    Type_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Output::unsafe_arena_set_allocated_error(::ArmoniK::api::grpc::v1::Output_Error* error) {
  clear_Type();
  if (error) {
    set_has_error();
    Type_.error_ = error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ArmoniK.api.grpc.v1.Output.error)
}
inline ::ArmoniK::api::grpc::v1::Output_Error* Output::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_Type();
    set_has_error();
    Type_.error_ = CreateMaybeMessage< ::ArmoniK::api::grpc::v1::Output_Error >(GetArenaForAllocation());
  }
  return Type_.error_;
}
inline ::ArmoniK::api::grpc::v1::Output_Error* Output::mutable_error() {
  ::ArmoniK::api::grpc::v1::Output_Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:ArmoniK.api.grpc.v1.Output.error)
  return _msg;
}

inline bool Output::has_Type() const {
  return Type_case() != TYPE_NOT_SET;
}
inline void Output::clear_has_Type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Output::TypeCase Output::Type_case() const {
  return Output::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TaskRequest

// string id = 1;
inline void TaskRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& TaskRequest::id() const {
  // @@protoc_insertion_point(field_get:ArmoniK.api.grpc.v1.TaskRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ArmoniK.api.grpc.v1.TaskRequest.id)
}
inline std::string* TaskRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ArmoniK.api.grpc.v1.TaskRequest.id)
  return _s;
}
inline const std::string& TaskRequest::_internal_id() const {
  return id_.Get();
}
inline void TaskRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskRequest::release_id() {
  // @@protoc_insertion_point(field_release:ArmoniK.api.grpc.v1.TaskRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ArmoniK.api.grpc.v1.TaskRequest.id)
}

// repeated string expected_output_keys = 2;
inline int TaskRequest::_internal_expected_output_keys_size() const {
  return expected_output_keys_.size();
}
inline int TaskRequest::expected_output_keys_size() const {
  return _internal_expected_output_keys_size();
}
inline void TaskRequest::clear_expected_output_keys() {
  expected_output_keys_.Clear();
}
inline std::string* TaskRequest::add_expected_output_keys() {
  std::string* _s = _internal_add_expected_output_keys();
  // @@protoc_insertion_point(field_add_mutable:ArmoniK.api.grpc.v1.TaskRequest.expected_output_keys)
  return _s;
}
inline const std::string& TaskRequest::_internal_expected_output_keys(int index) const {
  return expected_output_keys_.Get(index);
}
inline const std::string& TaskRequest::expected_output_keys(int index) const {
  // @@protoc_insertion_point(field_get:ArmoniK.api.grpc.v1.TaskRequest.expected_output_keys)
  return _internal_expected_output_keys(index);
}
inline std::string* TaskRequest::mutable_expected_output_keys(int index) {
  // @@protoc_insertion_point(field_mutable:ArmoniK.api.grpc.v1.TaskRequest.expected_output_keys)
  return expected_output_keys_.Mutable(index);
}
inline void TaskRequest::set_expected_output_keys(int index, const std::string& value) {
  expected_output_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ArmoniK.api.grpc.v1.TaskRequest.expected_output_keys)
}
inline void TaskRequest::set_expected_output_keys(int index, std::string&& value) {
  expected_output_keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ArmoniK.api.grpc.v1.TaskRequest.expected_output_keys)
}
inline void TaskRequest::set_expected_output_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  expected_output_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ArmoniK.api.grpc.v1.TaskRequest.expected_output_keys)
}
inline void TaskRequest::set_expected_output_keys(int index, const char* value, size_t size) {
  expected_output_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ArmoniK.api.grpc.v1.TaskRequest.expected_output_keys)
}
inline std::string* TaskRequest::_internal_add_expected_output_keys() {
  return expected_output_keys_.Add();
}
inline void TaskRequest::add_expected_output_keys(const std::string& value) {
  expected_output_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ArmoniK.api.grpc.v1.TaskRequest.expected_output_keys)
}
inline void TaskRequest::add_expected_output_keys(std::string&& value) {
  expected_output_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ArmoniK.api.grpc.v1.TaskRequest.expected_output_keys)
}
inline void TaskRequest::add_expected_output_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  expected_output_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ArmoniK.api.grpc.v1.TaskRequest.expected_output_keys)
}
inline void TaskRequest::add_expected_output_keys(const char* value, size_t size) {
  expected_output_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ArmoniK.api.grpc.v1.TaskRequest.expected_output_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TaskRequest::expected_output_keys() const {
  // @@protoc_insertion_point(field_list:ArmoniK.api.grpc.v1.TaskRequest.expected_output_keys)
  return expected_output_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TaskRequest::mutable_expected_output_keys() {
  // @@protoc_insertion_point(field_mutable_list:ArmoniK.api.grpc.v1.TaskRequest.expected_output_keys)
  return &expected_output_keys_;
}

// repeated string data_dependencies = 3;
inline int TaskRequest::_internal_data_dependencies_size() const {
  return data_dependencies_.size();
}
inline int TaskRequest::data_dependencies_size() const {
  return _internal_data_dependencies_size();
}
inline void TaskRequest::clear_data_dependencies() {
  data_dependencies_.Clear();
}
inline std::string* TaskRequest::add_data_dependencies() {
  std::string* _s = _internal_add_data_dependencies();
  // @@protoc_insertion_point(field_add_mutable:ArmoniK.api.grpc.v1.TaskRequest.data_dependencies)
  return _s;
}
inline const std::string& TaskRequest::_internal_data_dependencies(int index) const {
  return data_dependencies_.Get(index);
}
inline const std::string& TaskRequest::data_dependencies(int index) const {
  // @@protoc_insertion_point(field_get:ArmoniK.api.grpc.v1.TaskRequest.data_dependencies)
  return _internal_data_dependencies(index);
}
inline std::string* TaskRequest::mutable_data_dependencies(int index) {
  // @@protoc_insertion_point(field_mutable:ArmoniK.api.grpc.v1.TaskRequest.data_dependencies)
  return data_dependencies_.Mutable(index);
}
inline void TaskRequest::set_data_dependencies(int index, const std::string& value) {
  data_dependencies_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ArmoniK.api.grpc.v1.TaskRequest.data_dependencies)
}
inline void TaskRequest::set_data_dependencies(int index, std::string&& value) {
  data_dependencies_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ArmoniK.api.grpc.v1.TaskRequest.data_dependencies)
}
inline void TaskRequest::set_data_dependencies(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  data_dependencies_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ArmoniK.api.grpc.v1.TaskRequest.data_dependencies)
}
inline void TaskRequest::set_data_dependencies(int index, const char* value, size_t size) {
  data_dependencies_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ArmoniK.api.grpc.v1.TaskRequest.data_dependencies)
}
inline std::string* TaskRequest::_internal_add_data_dependencies() {
  return data_dependencies_.Add();
}
inline void TaskRequest::add_data_dependencies(const std::string& value) {
  data_dependencies_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ArmoniK.api.grpc.v1.TaskRequest.data_dependencies)
}
inline void TaskRequest::add_data_dependencies(std::string&& value) {
  data_dependencies_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ArmoniK.api.grpc.v1.TaskRequest.data_dependencies)
}
inline void TaskRequest::add_data_dependencies(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  data_dependencies_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ArmoniK.api.grpc.v1.TaskRequest.data_dependencies)
}
inline void TaskRequest::add_data_dependencies(const char* value, size_t size) {
  data_dependencies_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ArmoniK.api.grpc.v1.TaskRequest.data_dependencies)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TaskRequest::data_dependencies() const {
  // @@protoc_insertion_point(field_list:ArmoniK.api.grpc.v1.TaskRequest.data_dependencies)
  return data_dependencies_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TaskRequest::mutable_data_dependencies() {
  // @@protoc_insertion_point(field_mutable_list:ArmoniK.api.grpc.v1.TaskRequest.data_dependencies)
  return &data_dependencies_;
}

// bytes payload = 4;
inline void TaskRequest::clear_payload() {
  payload_.ClearToEmpty();
}
inline const std::string& TaskRequest::payload() const {
  // @@protoc_insertion_point(field_get:ArmoniK.api.grpc.v1.TaskRequest.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskRequest::set_payload(ArgT0&& arg0, ArgT... args) {
 
 payload_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ArmoniK.api.grpc.v1.TaskRequest.payload)
}
inline std::string* TaskRequest::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:ArmoniK.api.grpc.v1.TaskRequest.payload)
  return _s;
}
inline const std::string& TaskRequest::_internal_payload() const {
  return payload_.Get();
}
inline void TaskRequest::_internal_set_payload(const std::string& value) {
  
  payload_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskRequest::_internal_mutable_payload() {
  
  return payload_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskRequest::release_payload() {
  // @@protoc_insertion_point(field_release:ArmoniK.api.grpc.v1.TaskRequest.payload)
  return payload_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskRequest::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  payload_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payload,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (payload_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    payload_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ArmoniK.api.grpc.v1.TaskRequest.payload)
}

// -------------------------------------------------------------------

// InitKeyedDataStream

// string key = 1;
inline bool InitKeyedDataStream::_internal_has_key() const {
  return Type_case() == kKey;
}
inline bool InitKeyedDataStream::has_key() const {
  return _internal_has_key();
}
inline void InitKeyedDataStream::set_has_key() {
  _oneof_case_[0] = kKey;
}
inline void InitKeyedDataStream::clear_key() {
  if (_internal_has_key()) {
    Type_.key_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_Type();
  }
}
inline const std::string& InitKeyedDataStream::key() const {
  // @@protoc_insertion_point(field_get:ArmoniK.api.grpc.v1.InitKeyedDataStream.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline void InitKeyedDataStream::set_key(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_key()) {
    clear_Type();
    set_has_key();
    Type_.key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  Type_.key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ArmoniK.api.grpc.v1.InitKeyedDataStream.key)
}
inline std::string* InitKeyedDataStream::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:ArmoniK.api.grpc.v1.InitKeyedDataStream.key)
  return _s;
}
inline const std::string& InitKeyedDataStream::_internal_key() const {
  if (_internal_has_key()) {
    return Type_.key_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void InitKeyedDataStream::_internal_set_key(const std::string& value) {
  if (!_internal_has_key()) {
    clear_Type();
    set_has_key();
    Type_.key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  Type_.key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InitKeyedDataStream::_internal_mutable_key() {
  if (!_internal_has_key()) {
    clear_Type();
    set_has_key();
    Type_.key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return Type_.key_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InitKeyedDataStream::release_key() {
  // @@protoc_insertion_point(field_release:ArmoniK.api.grpc.v1.InitKeyedDataStream.key)
  if (_internal_has_key()) {
    clear_has_Type();
    return Type_.key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void InitKeyedDataStream::set_allocated_key(std::string* key) {
  if (has_Type()) {
    clear_Type();
  }
  if (key != nullptr) {
    set_has_key();
    Type_.key_.UnsafeSetDefault(key);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(key);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:ArmoniK.api.grpc.v1.InitKeyedDataStream.key)
}

// bool last_result = 2;
inline bool InitKeyedDataStream::_internal_has_last_result() const {
  return Type_case() == kLastResult;
}
inline bool InitKeyedDataStream::has_last_result() const {
  return _internal_has_last_result();
}
inline void InitKeyedDataStream::set_has_last_result() {
  _oneof_case_[0] = kLastResult;
}
inline void InitKeyedDataStream::clear_last_result() {
  if (_internal_has_last_result()) {
    Type_.last_result_ = false;
    clear_has_Type();
  }
}
inline bool InitKeyedDataStream::_internal_last_result() const {
  if (_internal_has_last_result()) {
    return Type_.last_result_;
  }
  return false;
}
inline void InitKeyedDataStream::_internal_set_last_result(bool value) {
  if (!_internal_has_last_result()) {
    clear_Type();
    set_has_last_result();
  }
  Type_.last_result_ = value;
}
inline bool InitKeyedDataStream::last_result() const {
  // @@protoc_insertion_point(field_get:ArmoniK.api.grpc.v1.InitKeyedDataStream.last_result)
  return _internal_last_result();
}
inline void InitKeyedDataStream::set_last_result(bool value) {
  _internal_set_last_result(value);
  // @@protoc_insertion_point(field_set:ArmoniK.api.grpc.v1.InitKeyedDataStream.last_result)
}

inline bool InitKeyedDataStream::has_Type() const {
  return Type_case() != TYPE_NOT_SET;
}
inline void InitKeyedDataStream::clear_has_Type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline InitKeyedDataStream::TypeCase InitKeyedDataStream::Type_case() const {
  return InitKeyedDataStream::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// DataChunk

// bytes data = 1;
inline bool DataChunk::_internal_has_data() const {
  return Type_case() == kData;
}
inline bool DataChunk::has_data() const {
  return _internal_has_data();
}
inline void DataChunk::set_has_data() {
  _oneof_case_[0] = kData;
}
inline void DataChunk::clear_data() {
  if (_internal_has_data()) {
    Type_.data_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_Type();
  }
}
inline const std::string& DataChunk::data() const {
  // @@protoc_insertion_point(field_get:ArmoniK.api.grpc.v1.DataChunk.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline void DataChunk::set_data(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_data()) {
    clear_Type();
    set_has_data();
    Type_.data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  Type_.data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ArmoniK.api.grpc.v1.DataChunk.data)
}
inline std::string* DataChunk::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:ArmoniK.api.grpc.v1.DataChunk.data)
  return _s;
}
inline const std::string& DataChunk::_internal_data() const {
  if (_internal_has_data()) {
    return Type_.data_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DataChunk::_internal_set_data(const std::string& value) {
  if (!_internal_has_data()) {
    clear_Type();
    set_has_data();
    Type_.data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  Type_.data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DataChunk::_internal_mutable_data() {
  if (!_internal_has_data()) {
    clear_Type();
    set_has_data();
    Type_.data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return Type_.data_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DataChunk::release_data() {
  // @@protoc_insertion_point(field_release:ArmoniK.api.grpc.v1.DataChunk.data)
  if (_internal_has_data()) {
    clear_has_Type();
    return Type_.data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void DataChunk::set_allocated_data(std::string* data) {
  if (has_Type()) {
    clear_Type();
  }
  if (data != nullptr) {
    set_has_data();
    Type_.data_.UnsafeSetDefault(data);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(data);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:ArmoniK.api.grpc.v1.DataChunk.data)
}

// bool dataComplete = 2;
inline bool DataChunk::_internal_has_datacomplete() const {
  return Type_case() == kDataComplete;
}
inline bool DataChunk::has_datacomplete() const {
  return _internal_has_datacomplete();
}
inline void DataChunk::set_has_datacomplete() {
  _oneof_case_[0] = kDataComplete;
}
inline void DataChunk::clear_datacomplete() {
  if (_internal_has_datacomplete()) {
    Type_.datacomplete_ = false;
    clear_has_Type();
  }
}
inline bool DataChunk::_internal_datacomplete() const {
  if (_internal_has_datacomplete()) {
    return Type_.datacomplete_;
  }
  return false;
}
inline void DataChunk::_internal_set_datacomplete(bool value) {
  if (!_internal_has_datacomplete()) {
    clear_Type();
    set_has_datacomplete();
  }
  Type_.datacomplete_ = value;
}
inline bool DataChunk::datacomplete() const {
  // @@protoc_insertion_point(field_get:ArmoniK.api.grpc.v1.DataChunk.dataComplete)
  return _internal_datacomplete();
}
inline void DataChunk::set_datacomplete(bool value) {
  _internal_set_datacomplete(value);
  // @@protoc_insertion_point(field_set:ArmoniK.api.grpc.v1.DataChunk.dataComplete)
}

inline bool DataChunk::has_Type() const {
  return Type_case() != TYPE_NOT_SET;
}
inline void DataChunk::clear_has_Type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline DataChunk::TypeCase DataChunk::Type_case() const {
  return DataChunk::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TaskRequestHeader

// string id = 1;
inline void TaskRequestHeader::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& TaskRequestHeader::id() const {
  // @@protoc_insertion_point(field_get:ArmoniK.api.grpc.v1.TaskRequestHeader.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskRequestHeader::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ArmoniK.api.grpc.v1.TaskRequestHeader.id)
}
inline std::string* TaskRequestHeader::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ArmoniK.api.grpc.v1.TaskRequestHeader.id)
  return _s;
}
inline const std::string& TaskRequestHeader::_internal_id() const {
  return id_.Get();
}
inline void TaskRequestHeader::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskRequestHeader::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskRequestHeader::release_id() {
  // @@protoc_insertion_point(field_release:ArmoniK.api.grpc.v1.TaskRequestHeader.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskRequestHeader::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ArmoniK.api.grpc.v1.TaskRequestHeader.id)
}

// repeated string expected_output_keys = 3;
inline int TaskRequestHeader::_internal_expected_output_keys_size() const {
  return expected_output_keys_.size();
}
inline int TaskRequestHeader::expected_output_keys_size() const {
  return _internal_expected_output_keys_size();
}
inline void TaskRequestHeader::clear_expected_output_keys() {
  expected_output_keys_.Clear();
}
inline std::string* TaskRequestHeader::add_expected_output_keys() {
  std::string* _s = _internal_add_expected_output_keys();
  // @@protoc_insertion_point(field_add_mutable:ArmoniK.api.grpc.v1.TaskRequestHeader.expected_output_keys)
  return _s;
}
inline const std::string& TaskRequestHeader::_internal_expected_output_keys(int index) const {
  return expected_output_keys_.Get(index);
}
inline const std::string& TaskRequestHeader::expected_output_keys(int index) const {
  // @@protoc_insertion_point(field_get:ArmoniK.api.grpc.v1.TaskRequestHeader.expected_output_keys)
  return _internal_expected_output_keys(index);
}
inline std::string* TaskRequestHeader::mutable_expected_output_keys(int index) {
  // @@protoc_insertion_point(field_mutable:ArmoniK.api.grpc.v1.TaskRequestHeader.expected_output_keys)
  return expected_output_keys_.Mutable(index);
}
inline void TaskRequestHeader::set_expected_output_keys(int index, const std::string& value) {
  expected_output_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ArmoniK.api.grpc.v1.TaskRequestHeader.expected_output_keys)
}
inline void TaskRequestHeader::set_expected_output_keys(int index, std::string&& value) {
  expected_output_keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ArmoniK.api.grpc.v1.TaskRequestHeader.expected_output_keys)
}
inline void TaskRequestHeader::set_expected_output_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  expected_output_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ArmoniK.api.grpc.v1.TaskRequestHeader.expected_output_keys)
}
inline void TaskRequestHeader::set_expected_output_keys(int index, const char* value, size_t size) {
  expected_output_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ArmoniK.api.grpc.v1.TaskRequestHeader.expected_output_keys)
}
inline std::string* TaskRequestHeader::_internal_add_expected_output_keys() {
  return expected_output_keys_.Add();
}
inline void TaskRequestHeader::add_expected_output_keys(const std::string& value) {
  expected_output_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ArmoniK.api.grpc.v1.TaskRequestHeader.expected_output_keys)
}
inline void TaskRequestHeader::add_expected_output_keys(std::string&& value) {
  expected_output_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ArmoniK.api.grpc.v1.TaskRequestHeader.expected_output_keys)
}
inline void TaskRequestHeader::add_expected_output_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  expected_output_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ArmoniK.api.grpc.v1.TaskRequestHeader.expected_output_keys)
}
inline void TaskRequestHeader::add_expected_output_keys(const char* value, size_t size) {
  expected_output_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ArmoniK.api.grpc.v1.TaskRequestHeader.expected_output_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TaskRequestHeader::expected_output_keys() const {
  // @@protoc_insertion_point(field_list:ArmoniK.api.grpc.v1.TaskRequestHeader.expected_output_keys)
  return expected_output_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TaskRequestHeader::mutable_expected_output_keys() {
  // @@protoc_insertion_point(field_mutable_list:ArmoniK.api.grpc.v1.TaskRequestHeader.expected_output_keys)
  return &expected_output_keys_;
}

// repeated string data_dependencies = 4;
inline int TaskRequestHeader::_internal_data_dependencies_size() const {
  return data_dependencies_.size();
}
inline int TaskRequestHeader::data_dependencies_size() const {
  return _internal_data_dependencies_size();
}
inline void TaskRequestHeader::clear_data_dependencies() {
  data_dependencies_.Clear();
}
inline std::string* TaskRequestHeader::add_data_dependencies() {
  std::string* _s = _internal_add_data_dependencies();
  // @@protoc_insertion_point(field_add_mutable:ArmoniK.api.grpc.v1.TaskRequestHeader.data_dependencies)
  return _s;
}
inline const std::string& TaskRequestHeader::_internal_data_dependencies(int index) const {
  return data_dependencies_.Get(index);
}
inline const std::string& TaskRequestHeader::data_dependencies(int index) const {
  // @@protoc_insertion_point(field_get:ArmoniK.api.grpc.v1.TaskRequestHeader.data_dependencies)
  return _internal_data_dependencies(index);
}
inline std::string* TaskRequestHeader::mutable_data_dependencies(int index) {
  // @@protoc_insertion_point(field_mutable:ArmoniK.api.grpc.v1.TaskRequestHeader.data_dependencies)
  return data_dependencies_.Mutable(index);
}
inline void TaskRequestHeader::set_data_dependencies(int index, const std::string& value) {
  data_dependencies_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ArmoniK.api.grpc.v1.TaskRequestHeader.data_dependencies)
}
inline void TaskRequestHeader::set_data_dependencies(int index, std::string&& value) {
  data_dependencies_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ArmoniK.api.grpc.v1.TaskRequestHeader.data_dependencies)
}
inline void TaskRequestHeader::set_data_dependencies(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  data_dependencies_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ArmoniK.api.grpc.v1.TaskRequestHeader.data_dependencies)
}
inline void TaskRequestHeader::set_data_dependencies(int index, const char* value, size_t size) {
  data_dependencies_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ArmoniK.api.grpc.v1.TaskRequestHeader.data_dependencies)
}
inline std::string* TaskRequestHeader::_internal_add_data_dependencies() {
  return data_dependencies_.Add();
}
inline void TaskRequestHeader::add_data_dependencies(const std::string& value) {
  data_dependencies_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ArmoniK.api.grpc.v1.TaskRequestHeader.data_dependencies)
}
inline void TaskRequestHeader::add_data_dependencies(std::string&& value) {
  data_dependencies_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ArmoniK.api.grpc.v1.TaskRequestHeader.data_dependencies)
}
inline void TaskRequestHeader::add_data_dependencies(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  data_dependencies_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ArmoniK.api.grpc.v1.TaskRequestHeader.data_dependencies)
}
inline void TaskRequestHeader::add_data_dependencies(const char* value, size_t size) {
  data_dependencies_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ArmoniK.api.grpc.v1.TaskRequestHeader.data_dependencies)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TaskRequestHeader::data_dependencies() const {
  // @@protoc_insertion_point(field_list:ArmoniK.api.grpc.v1.TaskRequestHeader.data_dependencies)
  return data_dependencies_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TaskRequestHeader::mutable_data_dependencies() {
  // @@protoc_insertion_point(field_mutable_list:ArmoniK.api.grpc.v1.TaskRequestHeader.data_dependencies)
  return &data_dependencies_;
}

// -------------------------------------------------------------------

// InitTaskRequest

// .ArmoniK.api.grpc.v1.TaskRequestHeader header = 1;
inline bool InitTaskRequest::_internal_has_header() const {
  return Type_case() == kHeader;
}
inline bool InitTaskRequest::has_header() const {
  return _internal_has_header();
}
inline void InitTaskRequest::set_has_header() {
  _oneof_case_[0] = kHeader;
}
inline void InitTaskRequest::clear_header() {
  if (_internal_has_header()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Type_.header_;
    }
    clear_has_Type();
  }
}
inline ::ArmoniK::api::grpc::v1::TaskRequestHeader* InitTaskRequest::release_header() {
  // @@protoc_insertion_point(field_release:ArmoniK.api.grpc.v1.InitTaskRequest.header)
  if (_internal_has_header()) {
    clear_has_Type();
      ::ArmoniK::api::grpc::v1::TaskRequestHeader* temp = Type_.header_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.header_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ArmoniK::api::grpc::v1::TaskRequestHeader& InitTaskRequest::_internal_header() const {
  return _internal_has_header()
      ? *Type_.header_
      : reinterpret_cast< ::ArmoniK::api::grpc::v1::TaskRequestHeader&>(::ArmoniK::api::grpc::v1::_TaskRequestHeader_default_instance_);
}
inline const ::ArmoniK::api::grpc::v1::TaskRequestHeader& InitTaskRequest::header() const {
  // @@protoc_insertion_point(field_get:ArmoniK.api.grpc.v1.InitTaskRequest.header)
  return _internal_header();
}
inline ::ArmoniK::api::grpc::v1::TaskRequestHeader* InitTaskRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ArmoniK.api.grpc.v1.InitTaskRequest.header)
  if (_internal_has_header()) {
    clear_has_Type();
    ::ArmoniK::api::grpc::v1::TaskRequestHeader* temp = Type_.header_;
    Type_.header_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InitTaskRequest::unsafe_arena_set_allocated_header(::ArmoniK::api::grpc::v1::TaskRequestHeader* header) {
  clear_Type();
  if (header) {
    set_has_header();
    Type_.header_ = header;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ArmoniK.api.grpc.v1.InitTaskRequest.header)
}
inline ::ArmoniK::api::grpc::v1::TaskRequestHeader* InitTaskRequest::_internal_mutable_header() {
  if (!_internal_has_header()) {
    clear_Type();
    set_has_header();
    Type_.header_ = CreateMaybeMessage< ::ArmoniK::api::grpc::v1::TaskRequestHeader >(GetArenaForAllocation());
  }
  return Type_.header_;
}
inline ::ArmoniK::api::grpc::v1::TaskRequestHeader* InitTaskRequest::mutable_header() {
  ::ArmoniK::api::grpc::v1::TaskRequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:ArmoniK.api.grpc.v1.InitTaskRequest.header)
  return _msg;
}

// bool last_task = 2;
inline bool InitTaskRequest::_internal_has_last_task() const {
  return Type_case() == kLastTask;
}
inline bool InitTaskRequest::has_last_task() const {
  return _internal_has_last_task();
}
inline void InitTaskRequest::set_has_last_task() {
  _oneof_case_[0] = kLastTask;
}
inline void InitTaskRequest::clear_last_task() {
  if (_internal_has_last_task()) {
    Type_.last_task_ = false;
    clear_has_Type();
  }
}
inline bool InitTaskRequest::_internal_last_task() const {
  if (_internal_has_last_task()) {
    return Type_.last_task_;
  }
  return false;
}
inline void InitTaskRequest::_internal_set_last_task(bool value) {
  if (!_internal_has_last_task()) {
    clear_Type();
    set_has_last_task();
  }
  Type_.last_task_ = value;
}
inline bool InitTaskRequest::last_task() const {
  // @@protoc_insertion_point(field_get:ArmoniK.api.grpc.v1.InitTaskRequest.last_task)
  return _internal_last_task();
}
inline void InitTaskRequest::set_last_task(bool value) {
  _internal_set_last_task(value);
  // @@protoc_insertion_point(field_set:ArmoniK.api.grpc.v1.InitTaskRequest.last_task)
}

inline bool InitTaskRequest::has_Type() const {
  return Type_case() != TYPE_NOT_SET;
}
inline void InitTaskRequest::clear_has_Type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline InitTaskRequest::TypeCase InitTaskRequest::Type_case() const {
  return InitTaskRequest::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TaskId

// string session = 1;
inline void TaskId::clear_session() {
  session_.ClearToEmpty();
}
inline const std::string& TaskId::session() const {
  // @@protoc_insertion_point(field_get:ArmoniK.api.grpc.v1.TaskId.session)
  return _internal_session();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskId::set_session(ArgT0&& arg0, ArgT... args) {
 
 session_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ArmoniK.api.grpc.v1.TaskId.session)
}
inline std::string* TaskId::mutable_session() {
  std::string* _s = _internal_mutable_session();
  // @@protoc_insertion_point(field_mutable:ArmoniK.api.grpc.v1.TaskId.session)
  return _s;
}
inline const std::string& TaskId::_internal_session() const {
  return session_.Get();
}
inline void TaskId::_internal_set_session(const std::string& value) {
  
  session_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskId::_internal_mutable_session() {
  
  return session_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskId::release_session() {
  // @@protoc_insertion_point(field_release:ArmoniK.api.grpc.v1.TaskId.session)
  return session_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskId::set_allocated_session(std::string* session) {
  if (session != nullptr) {
    
  } else {
    
  }
  session_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), session,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (session_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    session_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ArmoniK.api.grpc.v1.TaskId.session)
}

// string task = 2;
inline void TaskId::clear_task() {
  task_.ClearToEmpty();
}
inline const std::string& TaskId::task() const {
  // @@protoc_insertion_point(field_get:ArmoniK.api.grpc.v1.TaskId.task)
  return _internal_task();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskId::set_task(ArgT0&& arg0, ArgT... args) {
 
 task_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ArmoniK.api.grpc.v1.TaskId.task)
}
inline std::string* TaskId::mutable_task() {
  std::string* _s = _internal_mutable_task();
  // @@protoc_insertion_point(field_mutable:ArmoniK.api.grpc.v1.TaskId.task)
  return _s;
}
inline const std::string& TaskId::_internal_task() const {
  return task_.Get();
}
inline void TaskId::_internal_set_task(const std::string& value) {
  
  task_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskId::_internal_mutable_task() {
  
  return task_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskId::release_task() {
  // @@protoc_insertion_point(field_release:ArmoniK.api.grpc.v1.TaskId.task)
  return task_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskId::set_allocated_task(std::string* task) {
  if (task != nullptr) {
    
  } else {
    
  }
  task_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), task,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (task_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    task_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ArmoniK.api.grpc.v1.TaskId.task)
}

// -------------------------------------------------------------------

// TaskIdList

// repeated string task_ids = 1;
inline int TaskIdList::_internal_task_ids_size() const {
  return task_ids_.size();
}
inline int TaskIdList::task_ids_size() const {
  return _internal_task_ids_size();
}
inline void TaskIdList::clear_task_ids() {
  task_ids_.Clear();
}
inline std::string* TaskIdList::add_task_ids() {
  std::string* _s = _internal_add_task_ids();
  // @@protoc_insertion_point(field_add_mutable:ArmoniK.api.grpc.v1.TaskIdList.task_ids)
  return _s;
}
inline const std::string& TaskIdList::_internal_task_ids(int index) const {
  return task_ids_.Get(index);
}
inline const std::string& TaskIdList::task_ids(int index) const {
  // @@protoc_insertion_point(field_get:ArmoniK.api.grpc.v1.TaskIdList.task_ids)
  return _internal_task_ids(index);
}
inline std::string* TaskIdList::mutable_task_ids(int index) {
  // @@protoc_insertion_point(field_mutable:ArmoniK.api.grpc.v1.TaskIdList.task_ids)
  return task_ids_.Mutable(index);
}
inline void TaskIdList::set_task_ids(int index, const std::string& value) {
  task_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ArmoniK.api.grpc.v1.TaskIdList.task_ids)
}
inline void TaskIdList::set_task_ids(int index, std::string&& value) {
  task_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ArmoniK.api.grpc.v1.TaskIdList.task_ids)
}
inline void TaskIdList::set_task_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  task_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ArmoniK.api.grpc.v1.TaskIdList.task_ids)
}
inline void TaskIdList::set_task_ids(int index, const char* value, size_t size) {
  task_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ArmoniK.api.grpc.v1.TaskIdList.task_ids)
}
inline std::string* TaskIdList::_internal_add_task_ids() {
  return task_ids_.Add();
}
inline void TaskIdList::add_task_ids(const std::string& value) {
  task_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ArmoniK.api.grpc.v1.TaskIdList.task_ids)
}
inline void TaskIdList::add_task_ids(std::string&& value) {
  task_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ArmoniK.api.grpc.v1.TaskIdList.task_ids)
}
inline void TaskIdList::add_task_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  task_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ArmoniK.api.grpc.v1.TaskIdList.task_ids)
}
inline void TaskIdList::add_task_ids(const char* value, size_t size) {
  task_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ArmoniK.api.grpc.v1.TaskIdList.task_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TaskIdList::task_ids() const {
  // @@protoc_insertion_point(field_list:ArmoniK.api.grpc.v1.TaskIdList.task_ids)
  return task_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TaskIdList::mutable_task_ids() {
  // @@protoc_insertion_point(field_mutable_list:ArmoniK.api.grpc.v1.TaskIdList.task_ids)
  return &task_ids_;
}

// -------------------------------------------------------------------

// StatusCount

// .ArmoniK.api.grpc.v1.TaskStatus.TaskStatus status = 1;
inline void StatusCount::clear_status() {
  status_ = 0;
}
inline ::ArmoniK::api::grpc::v1::TaskStatus::TaskStatus StatusCount::_internal_status() const {
  return static_cast< ::ArmoniK::api::grpc::v1::TaskStatus::TaskStatus >(status_);
}
inline ::ArmoniK::api::grpc::v1::TaskStatus::TaskStatus StatusCount::status() const {
  // @@protoc_insertion_point(field_get:ArmoniK.api.grpc.v1.StatusCount.status)
  return _internal_status();
}
inline void StatusCount::_internal_set_status(::ArmoniK::api::grpc::v1::TaskStatus::TaskStatus value) {
  
  status_ = value;
}
inline void StatusCount::set_status(::ArmoniK::api::grpc::v1::TaskStatus::TaskStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:ArmoniK.api.grpc.v1.StatusCount.status)
}

// int32 count = 2;
inline void StatusCount::clear_count() {
  count_ = 0;
}
inline int32_t StatusCount::_internal_count() const {
  return count_;
}
inline int32_t StatusCount::count() const {
  // @@protoc_insertion_point(field_get:ArmoniK.api.grpc.v1.StatusCount.count)
  return _internal_count();
}
inline void StatusCount::_internal_set_count(int32_t value) {
  
  count_ = value;
}
inline void StatusCount::set_count(int32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:ArmoniK.api.grpc.v1.StatusCount.count)
}

// -------------------------------------------------------------------

// Count

// repeated .ArmoniK.api.grpc.v1.StatusCount values = 1;
inline int Count::_internal_values_size() const {
  return values_.size();
}
inline int Count::values_size() const {
  return _internal_values_size();
}
inline void Count::clear_values() {
  values_.Clear();
}
inline ::ArmoniK::api::grpc::v1::StatusCount* Count::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:ArmoniK.api.grpc.v1.Count.values)
  return values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ArmoniK::api::grpc::v1::StatusCount >*
Count::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:ArmoniK.api.grpc.v1.Count.values)
  return &values_;
}
inline const ::ArmoniK::api::grpc::v1::StatusCount& Count::_internal_values(int index) const {
  return values_.Get(index);
}
inline const ::ArmoniK::api::grpc::v1::StatusCount& Count::values(int index) const {
  // @@protoc_insertion_point(field_get:ArmoniK.api.grpc.v1.Count.values)
  return _internal_values(index);
}
inline ::ArmoniK::api::grpc::v1::StatusCount* Count::_internal_add_values() {
  return values_.Add();
}
inline ::ArmoniK::api::grpc::v1::StatusCount* Count::add_values() {
  ::ArmoniK::api::grpc::v1::StatusCount* _add = _internal_add_values();
  // @@protoc_insertion_point(field_add:ArmoniK.api.grpc.v1.Count.values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ArmoniK::api::grpc::v1::StatusCount >&
Count::values() const {
  // @@protoc_insertion_point(field_list:ArmoniK.api.grpc.v1.Count.values)
  return values_;
}

// -------------------------------------------------------------------

// ResultRequest

// string session = 1;
inline void ResultRequest::clear_session() {
  session_.ClearToEmpty();
}
inline const std::string& ResultRequest::session() const {
  // @@protoc_insertion_point(field_get:ArmoniK.api.grpc.v1.ResultRequest.session)
  return _internal_session();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResultRequest::set_session(ArgT0&& arg0, ArgT... args) {
 
 session_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ArmoniK.api.grpc.v1.ResultRequest.session)
}
inline std::string* ResultRequest::mutable_session() {
  std::string* _s = _internal_mutable_session();
  // @@protoc_insertion_point(field_mutable:ArmoniK.api.grpc.v1.ResultRequest.session)
  return _s;
}
inline const std::string& ResultRequest::_internal_session() const {
  return session_.Get();
}
inline void ResultRequest::_internal_set_session(const std::string& value) {
  
  session_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResultRequest::_internal_mutable_session() {
  
  return session_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResultRequest::release_session() {
  // @@protoc_insertion_point(field_release:ArmoniK.api.grpc.v1.ResultRequest.session)
  return session_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResultRequest::set_allocated_session(std::string* session) {
  if (session != nullptr) {
    
  } else {
    
  }
  session_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), session,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (session_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    session_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ArmoniK.api.grpc.v1.ResultRequest.session)
}

// string key = 2;
inline void ResultRequest::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& ResultRequest::key() const {
  // @@protoc_insertion_point(field_get:ArmoniK.api.grpc.v1.ResultRequest.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResultRequest::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ArmoniK.api.grpc.v1.ResultRequest.key)
}
inline std::string* ResultRequest::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:ArmoniK.api.grpc.v1.ResultRequest.key)
  return _s;
}
inline const std::string& ResultRequest::_internal_key() const {
  return key_.Get();
}
inline void ResultRequest::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResultRequest::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResultRequest::release_key() {
  // @@protoc_insertion_point(field_release:ArmoniK.api.grpc.v1.ResultRequest.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResultRequest::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ArmoniK.api.grpc.v1.ResultRequest.key)
}

// -------------------------------------------------------------------

// Error

// .ArmoniK.api.grpc.v1.TaskStatus.TaskStatus task_status = 1;
inline void Error::clear_task_status() {
  task_status_ = 0;
}
inline ::ArmoniK::api::grpc::v1::TaskStatus::TaskStatus Error::_internal_task_status() const {
  return static_cast< ::ArmoniK::api::grpc::v1::TaskStatus::TaskStatus >(task_status_);
}
inline ::ArmoniK::api::grpc::v1::TaskStatus::TaskStatus Error::task_status() const {
  // @@protoc_insertion_point(field_get:ArmoniK.api.grpc.v1.Error.task_status)
  return _internal_task_status();
}
inline void Error::_internal_set_task_status(::ArmoniK::api::grpc::v1::TaskStatus::TaskStatus value) {
  
  task_status_ = value;
}
inline void Error::set_task_status(::ArmoniK::api::grpc::v1::TaskStatus::TaskStatus value) {
  _internal_set_task_status(value);
  // @@protoc_insertion_point(field_set:ArmoniK.api.grpc.v1.Error.task_status)
}

// string detail = 2;
inline void Error::clear_detail() {
  detail_.ClearToEmpty();
}
inline const std::string& Error::detail() const {
  // @@protoc_insertion_point(field_get:ArmoniK.api.grpc.v1.Error.detail)
  return _internal_detail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Error::set_detail(ArgT0&& arg0, ArgT... args) {
 
 detail_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ArmoniK.api.grpc.v1.Error.detail)
}
inline std::string* Error::mutable_detail() {
  std::string* _s = _internal_mutable_detail();
  // @@protoc_insertion_point(field_mutable:ArmoniK.api.grpc.v1.Error.detail)
  return _s;
}
inline const std::string& Error::_internal_detail() const {
  return detail_.Get();
}
inline void Error::_internal_set_detail(const std::string& value) {
  
  detail_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Error::_internal_mutable_detail() {
  
  return detail_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Error::release_detail() {
  // @@protoc_insertion_point(field_release:ArmoniK.api.grpc.v1.Error.detail)
  return detail_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Error::set_allocated_detail(std::string* detail) {
  if (detail != nullptr) {
    
  } else {
    
  }
  detail_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), detail,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (detail_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    detail_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ArmoniK.api.grpc.v1.Error.detail)
}

// -------------------------------------------------------------------

// TaskError

// string task_id = 1;
inline void TaskError::clear_task_id() {
  task_id_.ClearToEmpty();
}
inline const std::string& TaskError::task_id() const {
  // @@protoc_insertion_point(field_get:ArmoniK.api.grpc.v1.TaskError.task_id)
  return _internal_task_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskError::set_task_id(ArgT0&& arg0, ArgT... args) {
 
 task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ArmoniK.api.grpc.v1.TaskError.task_id)
}
inline std::string* TaskError::mutable_task_id() {
  std::string* _s = _internal_mutable_task_id();
  // @@protoc_insertion_point(field_mutable:ArmoniK.api.grpc.v1.TaskError.task_id)
  return _s;
}
inline const std::string& TaskError::_internal_task_id() const {
  return task_id_.Get();
}
inline void TaskError::_internal_set_task_id(const std::string& value) {
  
  task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskError::_internal_mutable_task_id() {
  
  return task_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskError::release_task_id() {
  // @@protoc_insertion_point(field_release:ArmoniK.api.grpc.v1.TaskError.task_id)
  return task_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskError::set_allocated_task_id(std::string* task_id) {
  if (task_id != nullptr) {
    
  } else {
    
  }
  task_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), task_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (task_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    task_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ArmoniK.api.grpc.v1.TaskError.task_id)
}

// repeated .ArmoniK.api.grpc.v1.Error error = 2;
inline int TaskError::_internal_error_size() const {
  return error_.size();
}
inline int TaskError::error_size() const {
  return _internal_error_size();
}
inline void TaskError::clear_error() {
  error_.Clear();
}
inline ::ArmoniK::api::grpc::v1::Error* TaskError::mutable_error(int index) {
  // @@protoc_insertion_point(field_mutable:ArmoniK.api.grpc.v1.TaskError.error)
  return error_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ArmoniK::api::grpc::v1::Error >*
TaskError::mutable_error() {
  // @@protoc_insertion_point(field_mutable_list:ArmoniK.api.grpc.v1.TaskError.error)
  return &error_;
}
inline const ::ArmoniK::api::grpc::v1::Error& TaskError::_internal_error(int index) const {
  return error_.Get(index);
}
inline const ::ArmoniK::api::grpc::v1::Error& TaskError::error(int index) const {
  // @@protoc_insertion_point(field_get:ArmoniK.api.grpc.v1.TaskError.error)
  return _internal_error(index);
}
inline ::ArmoniK::api::grpc::v1::Error* TaskError::_internal_add_error() {
  return error_.Add();
}
inline ::ArmoniK::api::grpc::v1::Error* TaskError::add_error() {
  ::ArmoniK::api::grpc::v1::Error* _add = _internal_add_error();
  // @@protoc_insertion_point(field_add:ArmoniK.api.grpc.v1.TaskError.error)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ArmoniK::api::grpc::v1::Error >&
TaskError::error() const {
  // @@protoc_insertion_point(field_list:ArmoniK.api.grpc.v1.TaskError.error)
  return error_;
}

// -------------------------------------------------------------------

// CreateTaskReply_TaskIds

// repeated string ids = 1;
inline int CreateTaskReply_TaskIds::_internal_ids_size() const {
  return ids_.size();
}
inline int CreateTaskReply_TaskIds::ids_size() const {
  return _internal_ids_size();
}
inline void CreateTaskReply_TaskIds::clear_ids() {
  ids_.Clear();
}
inline std::string* CreateTaskReply_TaskIds::add_ids() {
  std::string* _s = _internal_add_ids();
  // @@protoc_insertion_point(field_add_mutable:ArmoniK.api.grpc.v1.CreateTaskReply.TaskIds.ids)
  return _s;
}
inline const std::string& CreateTaskReply_TaskIds::_internal_ids(int index) const {
  return ids_.Get(index);
}
inline const std::string& CreateTaskReply_TaskIds::ids(int index) const {
  // @@protoc_insertion_point(field_get:ArmoniK.api.grpc.v1.CreateTaskReply.TaskIds.ids)
  return _internal_ids(index);
}
inline std::string* CreateTaskReply_TaskIds::mutable_ids(int index) {
  // @@protoc_insertion_point(field_mutable:ArmoniK.api.grpc.v1.CreateTaskReply.TaskIds.ids)
  return ids_.Mutable(index);
}
inline void CreateTaskReply_TaskIds::set_ids(int index, const std::string& value) {
  ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ArmoniK.api.grpc.v1.CreateTaskReply.TaskIds.ids)
}
inline void CreateTaskReply_TaskIds::set_ids(int index, std::string&& value) {
  ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ArmoniK.api.grpc.v1.CreateTaskReply.TaskIds.ids)
}
inline void CreateTaskReply_TaskIds::set_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ArmoniK.api.grpc.v1.CreateTaskReply.TaskIds.ids)
}
inline void CreateTaskReply_TaskIds::set_ids(int index, const char* value, size_t size) {
  ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ArmoniK.api.grpc.v1.CreateTaskReply.TaskIds.ids)
}
inline std::string* CreateTaskReply_TaskIds::_internal_add_ids() {
  return ids_.Add();
}
inline void CreateTaskReply_TaskIds::add_ids(const std::string& value) {
  ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ArmoniK.api.grpc.v1.CreateTaskReply.TaskIds.ids)
}
inline void CreateTaskReply_TaskIds::add_ids(std::string&& value) {
  ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ArmoniK.api.grpc.v1.CreateTaskReply.TaskIds.ids)
}
inline void CreateTaskReply_TaskIds::add_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ArmoniK.api.grpc.v1.CreateTaskReply.TaskIds.ids)
}
inline void CreateTaskReply_TaskIds::add_ids(const char* value, size_t size) {
  ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ArmoniK.api.grpc.v1.CreateTaskReply.TaskIds.ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CreateTaskReply_TaskIds::ids() const {
  // @@protoc_insertion_point(field_list:ArmoniK.api.grpc.v1.CreateTaskReply.TaskIds.ids)
  return ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CreateTaskReply_TaskIds::mutable_ids() {
  // @@protoc_insertion_point(field_mutable_list:ArmoniK.api.grpc.v1.CreateTaskReply.TaskIds.ids)
  return &ids_;
}

// -------------------------------------------------------------------

// CreateTaskReply

// .ArmoniK.api.grpc.v1.Empty successfull = 1;
inline bool CreateTaskReply::_internal_has_successfull() const {
  return Data_case() == kSuccessfull;
}
inline bool CreateTaskReply::has_successfull() const {
  return _internal_has_successfull();
}
inline void CreateTaskReply::set_has_successfull() {
  _oneof_case_[0] = kSuccessfull;
}
inline void CreateTaskReply::clear_successfull() {
  if (_internal_has_successfull()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Data_.successfull_;
    }
    clear_has_Data();
  }
}
inline ::ArmoniK::api::grpc::v1::Empty* CreateTaskReply::release_successfull() {
  // @@protoc_insertion_point(field_release:ArmoniK.api.grpc.v1.CreateTaskReply.successfull)
  if (_internal_has_successfull()) {
    clear_has_Data();
      ::ArmoniK::api::grpc::v1::Empty* temp = Data_.successfull_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Data_.successfull_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ArmoniK::api::grpc::v1::Empty& CreateTaskReply::_internal_successfull() const {
  return _internal_has_successfull()
      ? *Data_.successfull_
      : reinterpret_cast< ::ArmoniK::api::grpc::v1::Empty&>(::ArmoniK::api::grpc::v1::_Empty_default_instance_);
}
inline const ::ArmoniK::api::grpc::v1::Empty& CreateTaskReply::successfull() const {
  // @@protoc_insertion_point(field_get:ArmoniK.api.grpc.v1.CreateTaskReply.successfull)
  return _internal_successfull();
}
inline ::ArmoniK::api::grpc::v1::Empty* CreateTaskReply::unsafe_arena_release_successfull() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ArmoniK.api.grpc.v1.CreateTaskReply.successfull)
  if (_internal_has_successfull()) {
    clear_has_Data();
    ::ArmoniK::api::grpc::v1::Empty* temp = Data_.successfull_;
    Data_.successfull_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CreateTaskReply::unsafe_arena_set_allocated_successfull(::ArmoniK::api::grpc::v1::Empty* successfull) {
  clear_Data();
  if (successfull) {
    set_has_successfull();
    Data_.successfull_ = successfull;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ArmoniK.api.grpc.v1.CreateTaskReply.successfull)
}
inline ::ArmoniK::api::grpc::v1::Empty* CreateTaskReply::_internal_mutable_successfull() {
  if (!_internal_has_successfull()) {
    clear_Data();
    set_has_successfull();
    Data_.successfull_ = CreateMaybeMessage< ::ArmoniK::api::grpc::v1::Empty >(GetArenaForAllocation());
  }
  return Data_.successfull_;
}
inline ::ArmoniK::api::grpc::v1::Empty* CreateTaskReply::mutable_successfull() {
  ::ArmoniK::api::grpc::v1::Empty* _msg = _internal_mutable_successfull();
  // @@protoc_insertion_point(field_mutable:ArmoniK.api.grpc.v1.CreateTaskReply.successfull)
  return _msg;
}

// .ArmoniK.api.grpc.v1.CreateTaskReply.TaskIds non_successfull_ids = 2;
inline bool CreateTaskReply::_internal_has_non_successfull_ids() const {
  return Data_case() == kNonSuccessfullIds;
}
inline bool CreateTaskReply::has_non_successfull_ids() const {
  return _internal_has_non_successfull_ids();
}
inline void CreateTaskReply::set_has_non_successfull_ids() {
  _oneof_case_[0] = kNonSuccessfullIds;
}
inline void CreateTaskReply::clear_non_successfull_ids() {
  if (_internal_has_non_successfull_ids()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Data_.non_successfull_ids_;
    }
    clear_has_Data();
  }
}
inline ::ArmoniK::api::grpc::v1::CreateTaskReply_TaskIds* CreateTaskReply::release_non_successfull_ids() {
  // @@protoc_insertion_point(field_release:ArmoniK.api.grpc.v1.CreateTaskReply.non_successfull_ids)
  if (_internal_has_non_successfull_ids()) {
    clear_has_Data();
      ::ArmoniK::api::grpc::v1::CreateTaskReply_TaskIds* temp = Data_.non_successfull_ids_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Data_.non_successfull_ids_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ArmoniK::api::grpc::v1::CreateTaskReply_TaskIds& CreateTaskReply::_internal_non_successfull_ids() const {
  return _internal_has_non_successfull_ids()
      ? *Data_.non_successfull_ids_
      : reinterpret_cast< ::ArmoniK::api::grpc::v1::CreateTaskReply_TaskIds&>(::ArmoniK::api::grpc::v1::_CreateTaskReply_TaskIds_default_instance_);
}
inline const ::ArmoniK::api::grpc::v1::CreateTaskReply_TaskIds& CreateTaskReply::non_successfull_ids() const {
  // @@protoc_insertion_point(field_get:ArmoniK.api.grpc.v1.CreateTaskReply.non_successfull_ids)
  return _internal_non_successfull_ids();
}
inline ::ArmoniK::api::grpc::v1::CreateTaskReply_TaskIds* CreateTaskReply::unsafe_arena_release_non_successfull_ids() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ArmoniK.api.grpc.v1.CreateTaskReply.non_successfull_ids)
  if (_internal_has_non_successfull_ids()) {
    clear_has_Data();
    ::ArmoniK::api::grpc::v1::CreateTaskReply_TaskIds* temp = Data_.non_successfull_ids_;
    Data_.non_successfull_ids_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CreateTaskReply::unsafe_arena_set_allocated_non_successfull_ids(::ArmoniK::api::grpc::v1::CreateTaskReply_TaskIds* non_successfull_ids) {
  clear_Data();
  if (non_successfull_ids) {
    set_has_non_successfull_ids();
    Data_.non_successfull_ids_ = non_successfull_ids;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ArmoniK.api.grpc.v1.CreateTaskReply.non_successfull_ids)
}
inline ::ArmoniK::api::grpc::v1::CreateTaskReply_TaskIds* CreateTaskReply::_internal_mutable_non_successfull_ids() {
  if (!_internal_has_non_successfull_ids()) {
    clear_Data();
    set_has_non_successfull_ids();
    Data_.non_successfull_ids_ = CreateMaybeMessage< ::ArmoniK::api::grpc::v1::CreateTaskReply_TaskIds >(GetArenaForAllocation());
  }
  return Data_.non_successfull_ids_;
}
inline ::ArmoniK::api::grpc::v1::CreateTaskReply_TaskIds* CreateTaskReply::mutable_non_successfull_ids() {
  ::ArmoniK::api::grpc::v1::CreateTaskReply_TaskIds* _msg = _internal_mutable_non_successfull_ids();
  // @@protoc_insertion_point(field_mutable:ArmoniK.api.grpc.v1.CreateTaskReply.non_successfull_ids)
  return _msg;
}

inline bool CreateTaskReply::has_Data() const {
  return Data_case() != DATA_NOT_SET;
}
inline void CreateTaskReply::clear_has_Data() {
  _oneof_case_[0] = DATA_NOT_SET;
}
inline CreateTaskReply::DataCase CreateTaskReply::Data_case() const {
  return CreateTaskReply::DataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TaskList

// repeated .ArmoniK.api.grpc.v1.TaskId taskIds = 1;
inline int TaskList::_internal_taskids_size() const {
  return taskids_.size();
}
inline int TaskList::taskids_size() const {
  return _internal_taskids_size();
}
inline void TaskList::clear_taskids() {
  taskids_.Clear();
}
inline ::ArmoniK::api::grpc::v1::TaskId* TaskList::mutable_taskids(int index) {
  // @@protoc_insertion_point(field_mutable:ArmoniK.api.grpc.v1.TaskList.taskIds)
  return taskids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ArmoniK::api::grpc::v1::TaskId >*
TaskList::mutable_taskids() {
  // @@protoc_insertion_point(field_mutable_list:ArmoniK.api.grpc.v1.TaskList.taskIds)
  return &taskids_;
}
inline const ::ArmoniK::api::grpc::v1::TaskId& TaskList::_internal_taskids(int index) const {
  return taskids_.Get(index);
}
inline const ::ArmoniK::api::grpc::v1::TaskId& TaskList::taskids(int index) const {
  // @@protoc_insertion_point(field_get:ArmoniK.api.grpc.v1.TaskList.taskIds)
  return _internal_taskids(index);
}
inline ::ArmoniK::api::grpc::v1::TaskId* TaskList::_internal_add_taskids() {
  return taskids_.Add();
}
inline ::ArmoniK::api::grpc::v1::TaskId* TaskList::add_taskids() {
  ::ArmoniK::api::grpc::v1::TaskId* _add = _internal_add_taskids();
  // @@protoc_insertion_point(field_add:ArmoniK.api.grpc.v1.TaskList.taskIds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ArmoniK::api::grpc::v1::TaskId >&
TaskList::taskids() const {
  // @@protoc_insertion_point(field_list:ArmoniK.api.grpc.v1.TaskList.taskIds)
  return taskids_;
}

// -------------------------------------------------------------------

// TaskIdWithStatus

// .ArmoniK.api.grpc.v1.TaskId TaskId = 1;
inline bool TaskIdWithStatus::_internal_has_taskid() const {
  return this != internal_default_instance() && taskid_ != nullptr;
}
inline bool TaskIdWithStatus::has_taskid() const {
  return _internal_has_taskid();
}
inline void TaskIdWithStatus::clear_taskid() {
  if (GetArenaForAllocation() == nullptr && taskid_ != nullptr) {
    delete taskid_;
  }
  taskid_ = nullptr;
}
inline const ::ArmoniK::api::grpc::v1::TaskId& TaskIdWithStatus::_internal_taskid() const {
  const ::ArmoniK::api::grpc::v1::TaskId* p = taskid_;
  return p != nullptr ? *p : reinterpret_cast<const ::ArmoniK::api::grpc::v1::TaskId&>(
      ::ArmoniK::api::grpc::v1::_TaskId_default_instance_);
}
inline const ::ArmoniK::api::grpc::v1::TaskId& TaskIdWithStatus::taskid() const {
  // @@protoc_insertion_point(field_get:ArmoniK.api.grpc.v1.TaskIdWithStatus.TaskId)
  return _internal_taskid();
}
inline void TaskIdWithStatus::unsafe_arena_set_allocated_taskid(
    ::ArmoniK::api::grpc::v1::TaskId* taskid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(taskid_);
  }
  taskid_ = taskid;
  if (taskid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ArmoniK.api.grpc.v1.TaskIdWithStatus.TaskId)
}
inline ::ArmoniK::api::grpc::v1::TaskId* TaskIdWithStatus::release_taskid() {
  
  ::ArmoniK::api::grpc::v1::TaskId* temp = taskid_;
  taskid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ArmoniK::api::grpc::v1::TaskId* TaskIdWithStatus::unsafe_arena_release_taskid() {
  // @@protoc_insertion_point(field_release:ArmoniK.api.grpc.v1.TaskIdWithStatus.TaskId)
  
  ::ArmoniK::api::grpc::v1::TaskId* temp = taskid_;
  taskid_ = nullptr;
  return temp;
}
inline ::ArmoniK::api::grpc::v1::TaskId* TaskIdWithStatus::_internal_mutable_taskid() {
  
  if (taskid_ == nullptr) {
    auto* p = CreateMaybeMessage<::ArmoniK::api::grpc::v1::TaskId>(GetArenaForAllocation());
    taskid_ = p;
  }
  return taskid_;
}
inline ::ArmoniK::api::grpc::v1::TaskId* TaskIdWithStatus::mutable_taskid() {
  ::ArmoniK::api::grpc::v1::TaskId* _msg = _internal_mutable_taskid();
  // @@protoc_insertion_point(field_mutable:ArmoniK.api.grpc.v1.TaskIdWithStatus.TaskId)
  return _msg;
}
inline void TaskIdWithStatus::set_allocated_taskid(::ArmoniK::api::grpc::v1::TaskId* taskid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete taskid_;
  }
  if (taskid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ArmoniK::api::grpc::v1::TaskId>::GetOwningArena(taskid);
    if (message_arena != submessage_arena) {
      taskid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, taskid, submessage_arena);
    }
    
  } else {
    
  }
  taskid_ = taskid;
  // @@protoc_insertion_point(field_set_allocated:ArmoniK.api.grpc.v1.TaskIdWithStatus.TaskId)
}

// .ArmoniK.api.grpc.v1.TaskStatus.TaskStatus Status = 2;
inline void TaskIdWithStatus::clear_status() {
  status_ = 0;
}
inline ::ArmoniK::api::grpc::v1::TaskStatus::TaskStatus TaskIdWithStatus::_internal_status() const {
  return static_cast< ::ArmoniK::api::grpc::v1::TaskStatus::TaskStatus >(status_);
}
inline ::ArmoniK::api::grpc::v1::TaskStatus::TaskStatus TaskIdWithStatus::status() const {
  // @@protoc_insertion_point(field_get:ArmoniK.api.grpc.v1.TaskIdWithStatus.Status)
  return _internal_status();
}
inline void TaskIdWithStatus::_internal_set_status(::ArmoniK::api::grpc::v1::TaskStatus::TaskStatus value) {
  
  status_ = value;
}
inline void TaskIdWithStatus::set_status(::ArmoniK::api::grpc::v1::TaskStatus::TaskStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:ArmoniK.api.grpc.v1.TaskIdWithStatus.Status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace grpc
}  // namespace api
}  // namespace ArmoniK

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_objects_2eproto
